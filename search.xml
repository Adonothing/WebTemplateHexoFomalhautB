<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单调队列专题</title>
      <link href="/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98.html"/>
      <url>/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-剑指-Offer-59-I-滑动窗口的最大值"><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">1.剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p>示例：</p><p><img src="../images/p23.jpg" alt="p23"></p><p><strong>思路</strong></p><p><strong>单调双端队列+滑窗：O(N)</strong></p><p>注意:</p><p><strong>1.边界条件:</strong></p><p>1.1 输入数组为空的情况；</p><p>1.2 队列弹出时注意前面加上判空操作；</p><p>1.3 peekFirst()与pollFirst()的用法区别；</p><p><strong>2.思路溯源：</strong></p><p>这里如果用暴力遍历的话，窗口每变化一次都要遍历所有元素找出当前窗口的最大值，渐进时间复杂度为:<strong>O(N*K)</strong></p><p>这里的输入上限为10^5说明总的运算量要达到10^10，绝对会超时的，10^5的输入理论复杂度上限大致在<strong>O(NlogN)</strong></p><p>因此必须要寻找复杂度更低的算法进行求解</p><p>那么最核心的问题就来了，如何在比O(N)小的时间复杂度内找出的窗口最大值呢?</p><p>办法其实有几种：一种可以用树形数据结构如<strong>堆、红黑树</strong>等，此时时间复杂度为O(logN)</p><p>还有一种就是<strong>单调双端队列</strong>：单调双端队列内部维护的仅仅是对于当前窗口所有可能的最大值</p><p>且最大值的顺序与窗口的走势一致，队头位置的最大值是目前窗口的最大值，并且是即将要第一个退出的</p><p>eg：队头[6, 5, 4, 3]队尾</p><p><strong>当有新元素nums[i]加入时是从队尾加入的：</strong></p><p>1.当<strong>nums[i]&gt;队尾</strong>时，队尾的可以弹出。</p><p>因为队尾的都不够nums[i]大，而窗口的中肯定是前面的队尾在前面，因此当前状态的最大值必定轮不到队尾</p><p>轮了nums[i]才会轮到队尾的元素，换句话说就是<strong>队尾元素不可能成为窗口最大值</strong></p><p>2.当<strong>nums[i]&lt;=队尾</strong>时，此时可以让队列保持单调递增(非严格)，nums[i]直接加入队尾。</p><p>因为队尾的元素&gt;=nums[i]，还是有可能成为最大值的，试想一下窗口只剩下 <strong>[队尾，nums[i]]</strong></p><p>因此队尾是一定要保留的，而nums[i]也要加入，因为后面可能有比nums[i]更小的！</p><p><strong>当有元素要弹出时是从队头弹出的：</strong></p><p>维护窗口的过程中，总有元素从左边退出。若该元素是队头元素就要弹出，因为单调队列维护的是<strong>窗口本身的可能的最大值</strong>，所以肯定要与窗口同步的；那不是队头的元素弹出窗口为何不用管？因为这些元素弹出不会影响窗口的最大值，eg:[1, 3, -1, -2]，此时-2要加入窗口，1要弹出窗口；此时队列尾[3, -1，-2]，最大值始终还是3，而1的位置在3出现之时已经不可能成为窗口最大值，谁叫她数值小并且先于3出现！因此1的退出不会影响窗口的最大值，而3的退出就会使得最大值从3变为-1。好好思考一下…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值</span><br><span class="hljs-comment">核心方法:单调双端队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 这里的长度可以通过举例子得到:len=4,k=2,窗口数目为3,即len-k+1</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len - k + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 创建单调递增的队列(队尾-&gt;队头),队头为此时窗口的最大值</span><br>    <span class="hljs-comment">// 如:队头[6,5,4,3,2]队尾,当nums[i]&gt;队尾元素时,为了维护递增的趋势将队尾元素弹出</span><br>    <span class="hljs-comment">// 当且仅当nums[i]&lt;=队尾元素时,才可以维护队列的递增,此时nums[i]加入队尾</span><br>    Deque&lt;Integer&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 初始化窗口nums[0,k-1]入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty() &amp;&amp; que.peekLast() &lt; nums[i]) que.pollLast();<br>        <span class="hljs-comment">// 当且仅当nums[i]&lt;=队尾元素时或者que为空时nums[i]入队</span><br>        que.addLast(nums[i]);<br>    &#125;<br>    <span class="hljs-comment">// 记录最大值的数组索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    res[index++] = que.peekFirst();<br>    <span class="hljs-comment">// 遍历后序窗口的最大值(以窗口结束索引为标记)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> k; j &lt; len; j++) &#123;<br>        <span class="hljs-comment">// 加入nums[j]同时维护递增队列</span><br>        <span class="hljs-keyword">while</span> (!que.isEmpty() &amp;&amp; nums[j] &gt; que.peekLast()) que.pollLast();<br>        que.addLast(nums[j]);<br>        <span class="hljs-comment">// 弹出nums[j-k]同时维护窗口元素对应</span><br>        <span class="hljs-keyword">if</span>(nums[j - k] == que.peekFirst()) que.pollFirst();<br>        <span class="hljs-comment">// 记录当前窗口的最大值进res(这里只是弹出来看看最大值是多少,不要真的弹出来了)</span><br>        res[index++] = que.peekFirst();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-剑指-Offer-59-II-队列的最大值"><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">2.剑指 Offer 59 - II. 队列的最大值</a></h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值。</p><p>要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>输入:</p><p>[“MaxQueue”,“push_back”,“push_back”,“max_value”,“pop_front”,“max_value”]</p><p>[[],[1],[2],[],[],[]]</p><p>输出:</p><p>[null,null,null,2,1,2]</p><p><strong>思路：</strong></p><p>​    <strong>单调递增队列O(1)内找出最大值</strong>:</p><p>​    利用单调队列维护当前队列中的可能的最大值，然后可以以O(1)的时间复杂度内返回最大值</p><p>​    注意：</p><p>1.增删元素保持两个队列元素同步</p><p>2.每当执行队列的方法时都要进行判空操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 能获取最大值的队列类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br>    <span class="hljs-comment">// 普通队列:按顺序存储所有元素</span><br>    Deque&lt;Integer&gt; que;<br>    <span class="hljs-comment">// 单调递增队列:用于维护当前队列中的最大值</span><br>    Deque&lt;Integer&gt; maxQue;<br>    <span class="hljs-comment">/*构造器*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxQueue</span><span class="hljs-params">()</span> &#123;<br>        que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        maxQue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/*获取最大值*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max_value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 最大值就是maxQue的队头元素(别忘了判空)</span><br>        <span class="hljs-keyword">return</span> maxQue.isEmpty() ? -<span class="hljs-number">1</span> : maxQue.peekFirst();<br>    &#125;<br><br>    <span class="hljs-comment">/*从队尾加入元素*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 加入元素:que直接加,maxQue要保持队列非严格递增(队尾-&gt;队头)</span><br>        que.add(value);<br>        <span class="hljs-keyword">while</span> (!maxQue.isEmpty() &amp;&amp; value &gt; maxQue.peekLast()) maxQue.pollLast();<br>        <span class="hljs-comment">// 弹出队尾比value小的值后,value加入队尾,保持maxQue单增</span><br>        maxQue.addLast(value);<br>    &#125;<br><br>    <span class="hljs-comment">/*从队头弹出元素*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop_front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 移除元素:que直接移除,maxQue要保持与que同步</span><br>        <span class="hljs-comment">// 不存在就要弹出-1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> que.isEmpty() ? -<span class="hljs-number">1</span> : que.pollFirst();<br>        <span class="hljs-comment">// 这里也要判空</span><br>        <span class="hljs-keyword">if</span>(poll != -<span class="hljs-number">1</span> &amp;&amp; poll == maxQue.peekFirst()) maxQue.pollFirst();<br>        <span class="hljs-keyword">return</span> poll;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法专题</title>
      <link href="/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98.html"/>
      <url>/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h3 id="LC679-24点游戏"><a href="https://leetcode.cn/problems/24-game/"><strong>LC679.24点游戏</strong></a></h3><p><strong>思路</strong></p><p>​    <strong>回溯法暴力遍历</strong>:(参考官方题解)</p><p>​    括号可以直接忽略,因为暴力遍历已经包含所有运算次序</p><p>​    4<em>3</em>4<em>3</em>2<em>4</em>2<em>1</em>4=9216种可能性</p><p>​    1.这个游戏的本质就是将其中两个数进行相乘的结果重新加入并进行新一轮原来的24点计算</p><p>​    2.排除几种特殊情况:</p><p>2.1 除0计算:这种情况直接跳过</p><p>​    2.2 乘法与加法的运算可以进行剪枝</p><p>​        2.3 误差考虑:当误差&lt;1e-6时,认为就是0</p><p>​    3.若最终都没有返回true说明找不到最后返回false</p><p>​    时间复杂度与空间复杂度均为:O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 计算误差</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">ERROR</span> <span class="hljs-operator">=</span> <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-comment">// 目标值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">TARGET</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>    <span class="hljs-comment">// 加减乘除</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PLUS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, MULTIPLY = <span class="hljs-number">1</span>, SUBTRACT = <span class="hljs-number">2</span>, DIVIDE = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    判断是否能凑成24</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judgePoint24</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cards)</span> &#123;<br>        List&lt;Double&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : cards) &#123;<br>            list.add((<span class="hljs-type">double</span>)num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(list);<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    dfs主函数:返回list中是否能计算出24</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Double&gt; list)</span> &#123;<br>        <span class="hljs-comment">// 递归出口1:空列表</span><br>        <span class="hljs-keyword">if</span>(list.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归出口2:运算结果为24</span><br>        <span class="hljs-keyword">if</span>(list.size() == <span class="hljs-number">1</span> &amp;&amp; Math.abs(list.get(<span class="hljs-number">0</span>) - TARGET) &lt; ERROR) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 先抽出两个要进行运算的数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                <span class="hljs-comment">// 注意是索引不同的两个数才能进行运算</span><br>                <span class="hljs-keyword">if</span>(i != j) &#123;<br>                    <span class="hljs-comment">// 再创建一个列表存放剩余的元素</span><br>                    List&lt;Double&gt; remain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; size; k++) &#123;<br>                        <span class="hljs-keyword">if</span>(k != i &amp;&amp; k != j) &#123;<br>                            remain.add(list.get(k));<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 在对选中的两个数list[i]与list[j]进行计算并加入remain列表</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                        <span class="hljs-comment">// 加法与除法进行剪枝(只保留i&gt;j部分一半)</span><br>                        <span class="hljs-keyword">if</span>(k &lt; <span class="hljs-number">2</span> &amp;&amp; i &lt; j) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(k == PLUS) &#123;<br>                            remain.add(list.get(i) + list.get(j));<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == MULTIPLY) &#123;<br>                            remain.add(list.get(i) * list.get(j));<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == SUBTRACT) &#123;<br>                            remain.add(list.get(i) - list.get(j));<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == DIVIDE) &#123;<br>                            <span class="hljs-comment">// 排除除0的情形</span><br>                            <span class="hljs-keyword">if</span>(list.get(j) &lt; ERROR) &#123;<br>                                <span class="hljs-keyword">continue</span>;<br>                            &#125;<span class="hljs-keyword">else</span> &#123;<br>                                remain.add(list.get(i) / list.get(j));<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">// 将加入运算结果的remain列表进行递归运算,若得到24直接返回true</span><br>                        <span class="hljs-keyword">if</span>(dfs(remain)) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 撤回操作刚刚的添加操作继续下一种符号的运算</span><br>                        remain.remove(remain.size() - <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若最后都找不到正确的选项,说明就是没有了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一点思考：</strong></p><p>其实回溯本质上就是递归+回退从而找到所有的路径(组合的可能)，最关键的就是要找到<strong>子问题</strong></p><p>问题：<strong>n个数进行组合运算能否得出24这个结果</strong></p><p>开始是4个数进行运算[1,2,3,4]</p><p>选其中两个数尝试，例如选了selected=[1,3]，剩余的是remain=[2,4]</p><p>那么将selected中的两个数进行 [+, -, <strong>, /] 4种运算得到的结果[4, -2, 3 , 0.3333…]分别再次放入remain中</strong></p><p><strong>判断这3个数进行运算的结果是否能得到24？</strong></p><p><strong>子问题由此产生：由4个数字的组合变成了3个数字的组合</strong></p><p><strong>若3个数字的组合能算出24可以马上推出4个数字的组合能就算出24！</strong></p><p>此时我们重复调用原本的函数就能解决这个3个数能否组成24的问题了→这就是递归！</p><p>在递归过程有不合格的案例进行回退并往另一条路径走，这就是回溯了！</p><p>例如我通过1+3=4，而[2,4,4]通过递归发现<strong>不能</strong>使得结果为24，因此这种情况就要<strong>舍弃</strong>了</p><p>怎样进行舍弃?</p><p>很简单，将[2,4,4]最后加入元素删掉就相当于返回上一层，可以继续进行下一个运算符的计算，再放进去[2,4]里面进行递归…</p><p>若某个dfs([x,x,x])返回true就说明这条路径是可行的</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找模板</title>
      <link href="/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF.html"/>
      <url>/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<p>二分查找要求数据有二段性，可以将查找某个分割点的时间复杂度从O(N)加速至O(logN)</p><p><a href="https://leetcode-cn.com/problems/binary-search/"><strong>LC704. 二分查找</strong></a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target</p><p>写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p><strong>示例1:</strong><br>输入： nums = [-1,0,3,5,9,12], target = 9 输出：4<br>解释：9出现在 nums中并且下标为4<br><strong>示例2:</strong><br>输入：nums = [-1,0,3,5,9,12],target = 2 输出：-1<br>解释：2不存在nums中因此返回-1</p><p><strong>思路：</strong></p><p><strong>二分查找-&gt;梦开始的地方</strong></p><p>这道题是二分查找的入门题目，二分查找的水非常深，但是简单的题目通常会由于各种原因丢分。</p><p>这里我总结一下二分查找的一些模板和做题套路</p><p>首先能用二分查找的<strong>前提</strong>是在<strong>可以根据f(mid)的值来判断下一个合法区间在mid左边还是右边</strong></p><p>因此二分查找前面通常都会有<strong>排序</strong>等步骤来确保问题具有**“二段性”**</p><p>总体要注意的：</p><p>1.while (l &lt; r)： 这种写法使得退出条件是<strong>l==r</strong>，因此执行完之后必定有l==r</p><p>2.mid的求法： 这个mid的求法非常讲究，我总结的是</p><ul><li>mid = l + (r - l + 1) / 2，mid主动偏右-&gt;右边界主动收缩r = mid - 1;</li><li>mid = l + (r - l ) / 2，mid主动偏左-&gt;左边界主动收缩l = mid + 1;</li></ul><p>3.下一个区间的判断采用减治思想，将一定不符合条件的先排除，如：nums[mid] &gt; target，那么mid必定不符合题意！-&gt;r = mid - 1</p><p>然后另外一个区间是其反面，一般是将合法区间包含在边界，如：nums[mid] &lt;=target，那么mid可能不符合题意！-&gt;l = mid</p><p>4.退出循环的时候要重复利用好l==r这个条件，答案蕴藏在其中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        在升序数组中查找目标数字对应下标-&gt;二分查找</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 下面是右边主动收缩</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// &gt;target,说明target在左边(不含)</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// &lt;=target,说明target在右边(含)</span><br>                l = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// l==r,nums[l]要不就是target;要不就是nums中没有target</span><br>        <span class="hljs-keyword">return</span> nums[l] == target ? l : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机DP总结</title>
      <link href="/%E7%8A%B6%E6%80%81%E6%9C%BADP%E6%80%BB%E7%BB%93.html"/>
      <url>/%E7%8A%B6%E6%80%81%E6%9C%BADP%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p><strong>状态机DP就是考虑到当前时刻、位置等的时候，有可能处于有限种情形中的其中一种</strong></p><p><strong>比如说当前位置的房子涂了什么颜色、当前时间的股票处于卖出还是买入的状态、当前删除到的序列是以0还是以1结尾、当前位置是放了还是没有放置东西、当前位置是正还是负</strong></p><p><strong>把这些情况分开来转移可以使得转移的思路更加清晰明了，类比成当前位置 i 的一个状态 j 能够由前面位置 i-1 的指定状态 k 转移得到！！！</strong></p><h3 id="1-粉刷房子问题">1.粉刷房子问题</h3><h4 id="1-1-LC123-剑指-Offer-II-091-粉刷房子">1.1 <strong>LC123.剑指 Offer II 091. 粉刷房子</strong></h4><p><strong>分状态的DP问题(序列DP):</strong></p><p>1.状态定义:dp[i][0],dp[i][1],dp[i][2]分别为粉刷房子[0,i],且房子i的颜色粉刷为红色/蓝色/绿色所花费的最低费用</p><p>​            <strong>为什么还要带一个后缀?因为粉刷第i间房子可能的状态本身有3种!</strong></p><p>​            <strong>如果混在一起讨论非常复杂,分开讨论可以根据前面的状态分开转移就非常方便</strong></p><p>​            <strong>类似于股票问题-&gt;考虑第i天且第i天处于卖出还是买入状态方便转移!</strong></p><p>2.状态转移:由于相邻的两个房子颜色不能相同,因此根据dp[i-1][j]的状态分类转移即可</p><p>​         2.1 dp[i][0]可以由dp[i-1][1]与dp[i-1][2]加上cost[i][0]取最小值转移</p><p>​         2.2 dp[i][1]可以由dp[i-1][0]与dp[i-1][2]加上cost[i][1]取最小值转移</p><p>​         2.3 dp[i][2]可以由dp[i-1][0]与dp[i-1][1]加上cost[i][2]取最小值转移</p><p>意义就是我这间房子涂了颜色0,那么只能由前面涂了不是颜色0的进行转移且取最小值</p><p>3.初始化:初始化dp[0][0]=cost[0][0],dp[0][1]=cost[0][1],dp[0][2]=cost[0][2]</p><p>4.遍历顺序:i正序,j无所谓</p><p>5.返回形式:涂到最后一间房子最小费用不知道是以哪种颜色结尾的,可以取最小值min(dp[n-1][0],dp[n-1][1],dp[n-1][2])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] costs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> costs.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = costs[i][<span class="hljs-number">0</span>] + Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>            dp[i][<span class="hljs-number">1</span>] = costs[i][<span class="hljs-number">1</span>] + Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = costs[i][<span class="hljs-number">2</span>] + Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], Math.min(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-LC1473-粉刷房子-III">1.2 <strong>LC1473. 粉刷房子 III</strong></h4><p>状态机DP问题(参考剑指OfferII.91  粉刷房子):</p><p>其实与之前那道粉刷房子的也很类似,不过这里更加复杂一点就是要考虑形成的街区数目,同时有的房子已经涂了色</p><p>我们前面一道题是考虑到两个dp维度:房子位置i,第i间房子的颜色j</p><p>要同时考虑形成的街区数目(独立),此时必须增加一个dp的维度k,表示当前形成的街区数目</p><p>同时要对已经涂了色的情况进行分类讨论转移</p><p>**1.状态定义:**dp[i][j][k]为考虑对房子[0,i]进行涂色,且房子i(i∈[0,m-1])颜色被涂为颜色j(j∈[1,n]),且涂完之后就形成k(k∈[1,target])个街区的最小花费</p><p>**2.状态转移:**我们以house[i]是否为0进行分类讨</p><p>​      2.1 house[i]==0 表示房子i还没有被涂色,选择任意颜色j∈[1,n]对房子i进行涂色,涂的具体颜色会影响街区的数目</p><p>​          dp[i][j][k]=cost[i][j-1]+min(dp[i-1][j][k],dp[i-1][j’][k-1]) 其中j’为≠j的集合(颜色不同街区数+1)</p><p>​          注意细节:合法的dp[i-1][jj][?]状态才能转移</p><p>​      2.2 house[i]!=0 表示房子i已经被涂色,此时只能对dp[i][house[i]][k]进行转移,其他dp[i][j’][?]无法转移仍为INF</p><p>​          dp[i][houses[i]][k]=0+min(dp[i-1][houses[i]][k],dp[i-1][j’][k-1]) 其中j’为≠houses[i]的集合(颜色不同街区数+1)</p><p>**3.初始化:**首先全部初始化为INF表示没有转移</p><p>​      当houses[0]==0时,dp[0][j][1]=cost[0][j-1] -&gt; 要涂色</p><p>​      当houses[0]!=0时,dp[0][houses[0]][1]=0 -&gt; 不用涂色</p><p>**4.遍历顺序:**显然i正序,j无所谓,k正序</p><p>**5.返回形式:**最后返回min(dp[m-1][j][target]),j∈[1,n] 若扔没有转移则返回-1</p><p><strong>时间复杂度:O((mn)^2) 空间复杂度:O(n*m^2)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span>[][] cost, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;   <span class="hljs-comment">// 哨兵</span><br>    <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            Arrays.fill(dp[i][j], INF);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (houses[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 1.首个房子不用涂色</span><br>        dp[<span class="hljs-number">0</span>][houses[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 2.首个房子要涂色,费用最小就是直接涂,且只能形成一个街区</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j][<span class="hljs-number">1</span>] = cost[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 遍历dp的每个状态</span><br>    <span class="hljs-comment">// i∈[1,m-1]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-comment">// j∈[1,n]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// k∈[1,target]</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= target; k++) &#123;<br>                <span class="hljs-keyword">if</span> (houses[i] == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 1.houses[i]要涂色</span><br>                    <span class="hljs-comment">// 遍历所有可能的houses[i-1]的颜色进行转移</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">jj</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; jj &lt;= n; jj++) &#123;<br>                        <span class="hljs-comment">// 细节:只有有效的状态才能进行转移</span><br>                        <span class="hljs-keyword">if</span> (jj == j &amp;&amp; dp[i - <span class="hljs-number">1</span>][jj][k] != INF) &#123;  <span class="hljs-comment">// 与前面颜色相同,街区数目不变</span><br>                            dp[i][j][k] = Math.min(dp[i][j][k], cost[i][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][jj][k]);<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jj != j &amp;&amp; dp[i - <span class="hljs-number">1</span>][jj][k - <span class="hljs-number">1</span>] != INF) &#123;    <span class="hljs-comment">// 与前面颜色不同,街区数目+1</span><br>                            dp[i][j][k] = Math.min(dp[i][j][k], cost[i][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][jj][k - <span class="hljs-number">1</span>]);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 2.houses[i]已经被涂色</span><br>                    <span class="hljs-keyword">if</span> (j == houses[i]) &#123;   <span class="hljs-comment">// 只能转移j==houses[i]的状态</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">jj</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; jj &lt;= n; jj++) &#123;<br>                            <span class="hljs-keyword">if</span> (jj == j &amp;&amp; dp[i - <span class="hljs-number">1</span>][jj][k] != INF) &#123;  <span class="hljs-comment">// 与前面颜色相同,街区数目不变(且不用花费)</span><br>                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i - <span class="hljs-number">1</span>][jj][k]);<br>                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jj != j &amp;&amp; dp[i - <span class="hljs-number">1</span>][jj][k - <span class="hljs-number">1</span>] != INF) &#123;    <span class="hljs-comment">// 与前面颜色不同,街区数目+1(且不用花费)</span><br>                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i - <span class="hljs-number">1</span>][jj][k - <span class="hljs-number">1</span>]);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结果为min(dp[m-1][j][target]),j∈[1,n] 不为INF部分的最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>        res = Math.min(res, dp[m - <span class="hljs-number">1</span>][j][target]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res == INF ? -<span class="hljs-number">1</span> : res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6种股票问题">2.6种股票问题</h3><h4 id="2-1-LC121-买卖股票的最佳时机">2.1 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/"><strong>LC121. 买卖股票的最佳时机</strong></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        dp五部曲:主要根据每天持有与不持有股票的状态进行转移</span><br><span class="hljs-comment">        1.状态定义:dp[i][0]代表第i天(操作后)不持有股票的最大身价,dp[i][0]代表第i天(操作后)持有股票的最大身价</span><br><span class="hljs-comment">        2.状态转移:</span><br><span class="hljs-comment">            2.1 dp[i][0]第i天不持有股票</span><br><span class="hljs-comment">                1.当天卖了:dp[i-1][1]+prices[i]</span><br><span class="hljs-comment">                2.之前就卖了:dp[i-1][0]</span><br><span class="hljs-comment">                3.还没买:0 (可以忽略)</span><br><span class="hljs-comment">            取最大值转移值dp[i][0]</span><br><span class="hljs-comment">            2.2  dp[i][1]第i天持有股票</span><br><span class="hljs-comment">                1.当天入手:-prices[i]</span><br><span class="hljs-comment">                2.之前就入手了:dp[i-1][1]</span><br><span class="hljs-comment">            取最大值转移值dp[i][1]</span><br><span class="hljs-comment">        3.初始化:第0天的情况-&gt;dp[0][0]=0,dp[0][1]=-prices[0]</span><br><span class="hljs-comment">        4.遍历顺序:i正序,j无所谓</span><br><span class="hljs-comment">        5.返回形式:最后一天肯定是卖出股票的身价大-&gt;dp[len-1][0];</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(-prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-LC122-买卖股票的最佳时机-II">2.2 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/"><strong>LC122. 买卖股票的最佳时机 II</strong></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        dp解法:</span><br><span class="hljs-comment">        1.状态定义:dp[i][0]代表第i天(操作后)不持有股票的最大身价,dp[i][0]代表第i天(操作后)持有股票的最大身价</span><br><span class="hljs-comment">        2.状态转移:</span><br><span class="hljs-comment">            2.1 dp[i][0]第i天不持有股票</span><br><span class="hljs-comment">                1.当天卖了:dp[i-1][1]+prices[i]</span><br><span class="hljs-comment">                2.之前就卖了:dp[i-1][0]</span><br><span class="hljs-comment">                3.还没买:0 (可以忽略)</span><br><span class="hljs-comment">            取最大值转移值dp[i][0]</span><br><span class="hljs-comment">            2.2  dp[i][1]第i天持有股票</span><br><span class="hljs-comment">                1.当天入手:dp[i-1][0]-prices[i] (区别在此,之前不持有股票可能已经交易过几轮了)</span><br><span class="hljs-comment">                2.之前就入手了:dp[i-1][1]</span><br><span class="hljs-comment">            取最大值转移值dp[i][1]</span><br><span class="hljs-comment">        3.初始化:第0天的情况-&gt;dp[0][0]=0,dp[0][1]=-prices[0]</span><br><span class="hljs-comment">        4.遍历顺序:i正序,j无所谓</span><br><span class="hljs-comment">        5.返回形式:最后一天肯定是卖出股票的身价大-&gt;dp[len-1][0]</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-LC123-买卖股票的最佳时机-III">2.3 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/"><strong>LC123. 买卖股票的最佳时机 III</strong></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        总体思路:第i天有5个阶段:0.还没买 1.第一次买入后 2.第一次抛售后 3.第二次迈买入后 4.第二次抛售后</span><br><span class="hljs-comment">        1.状态定义:dp[i][0]为处于的阶段0最大身价;dp[i][1]为处于阶段1最大身价;....</span><br><span class="hljs-comment">        2.状态转移:</span><br><span class="hljs-comment">            2.1 阶段0身价恒为0</span><br><span class="hljs-comment">            2.2 阶段1有两种情况:当天第一次买和之前第一次买了,取大的值:max(dp[i-1][0]-prices[i],dp[i-1][1])</span><br><span class="hljs-comment">            2.3 阶段2有两种情况:当天第一次卖和之前第一次卖了,取大的值:max(dp[i-1][1]+prices[i],dp[i-1][2])</span><br><span class="hljs-comment">            2.3 阶段3有两种情况:当天第二次买和之前第二次买了,取大的值:max(dp[i-1][2]-prices[i],dp[i-1][3])</span><br><span class="hljs-comment">            2.3 阶段4有两种情况:当天第二次卖和之前第二次卖了,取大的值:max(dp[i-1][3]+prices[i],dp[i-1][4])</span><br><span class="hljs-comment">        3.初始化:dp[0][0]=0,dp[0][1]=-prices[0],dp[0][2]=0,dp[0][3]=-prices[0],dp[0][4]=0</span><br><span class="hljs-comment">        4.遍历顺序:i正序,j无所谓</span><br><span class="hljs-comment">        5.返回形式:第一次卖出与第二次卖出取最大值:max(dp[len-1][2],dp[len-1][4])</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">5</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>            dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-LC188-买卖股票的最佳时机-IV">2.4 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/"><strong>LC188. 买卖股票的最佳时机 IV</strong></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        总体思路:与买卖股票的最佳时机 III 接近,将买卖股票的阶段分为第x次买入和第x次卖出</span><br><span class="hljs-comment">        状态0:处于还没买入过的阶段</span><br><span class="hljs-comment">        状态1:处于第1次买入后的阶段</span><br><span class="hljs-comment">        状态2:处于第1次卖出后的阶段</span><br><span class="hljs-comment">        状态3:处于第2次买入后的阶段</span><br><span class="hljs-comment">        状态4:处于第2次卖出后的阶段</span><br><span class="hljs-comment">        ...以此类推,dp[i][j]中的i代表的是处于第i天,j代表的当前股票的状态</span><br><span class="hljs-comment">        j为奇数时,表示处于第j/2+1次买入股票阶段;j为偶数时,表示处于第j/2次卖出股票阶段</span><br><span class="hljs-comment">        1.状态定义:dp[i][j]代表第i天处于的状态j时的最大收益</span><br><span class="hljs-comment">        2.状态转移:参考状态1与2可以推导出后面的</span><br><span class="hljs-comment">            2.0 还没买入过的阶段(j=0)-&gt;恒为0(直接初始化为0就可以完成求解)</span><br><span class="hljs-comment">            2.1 第1次买入后的阶段(j=1):今天刚买与之前就买了取较大值-&gt;max(dp[i-1][0]-prices[i],dp[i-1][1])</span><br><span class="hljs-comment">            2.2 第1次卖出后的阶段(j=2):今天刚卖与之前就卖了取较大值-&gt;max(dp[i-1][1]+prices[i],dp[i-1][2])</span><br><span class="hljs-comment">            ...以此类推,那么dp[i][j]可以以j为依据分为两种情况进行转移计算:</span><br><span class="hljs-comment">            j为奇数时-&gt;dp[i][j]=max(dp[i-1][j-1]-prices[i],dp[i-1][j])</span><br><span class="hljs-comment">            j为偶数时-&gt;dp[i][j]=max(dp[i-1][j-1]+prices[i],dp[i-1][j])</span><br><span class="hljs-comment">        3.初始化:j奇数表示买入的状态-&gt;dp[0][j]=-prices[0],j奇偶表示卖出的状态-&gt;dp[0][j]=0</span><br><span class="hljs-comment">        4.遍历顺序:i正序,j无所谓</span><br><span class="hljs-comment">        5.返回形式:返回dp[len-1][j]其中j为偶数的最大值(卖出时身价比持有时大)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> || prices.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-comment">// 统计j为奇数的情况:奇数+1就是偶数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][j]);<br>                dp[i][j + <span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j] + prices[i], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; j &lt;= <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<br>            max = Math.max(max, dp[len - <span class="hljs-number">1</span>][j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-LC309-最佳买卖股票时机含冷冻期">2.5 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/"><strong>LC309. 最佳买卖股票时机含冷冻期</strong></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        总体思路:与最佳买卖股票II比较类似,可以无限次交易但是含有冷冻期</span><br><span class="hljs-comment">        一共有以下6个状态:</span><br><span class="hljs-comment">        状态0:当前还没操作股票</span><br><span class="hljs-comment">        状态1:今天刚买入</span><br><span class="hljs-comment">        状态2:之前就买入了</span><br><span class="hljs-comment">        状态3:今天刚卖出</span><br><span class="hljs-comment">        状态4:处于冷冻期</span><br><span class="hljs-comment">        状态5:之前卖出且过了冷冻期</span><br><span class="hljs-comment">        1.状态定义:dp[i][j]表示第i天处于状态j的最大收益</span><br><span class="hljs-comment">        2.状态转移:</span><br><span class="hljs-comment">            2.0 dp[i][0]=0</span><br><span class="hljs-comment">            2.1 dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][5]-prices[i],dp[i-1][3]-prices[i])</span><br><span class="hljs-comment">                        =max(dp[i-1][5]-prices[i],dp[i-1][3]-prices[i])</span><br><span class="hljs-comment">            2.2 dp[i][2]=max(dp[i-1][1],dp[i-1][2])</span><br><span class="hljs-comment">            2.3 dp[i][3]=max(dp[i-1][2]+prices[i],dp[i-1][1]+prices[i])</span><br><span class="hljs-comment">            2.4 dp[i][4]=dp[i-1][3]</span><br><span class="hljs-comment">            2.5 dp[i][5]=max(dp[i-1][4],dp[i-1][5])</span><br><span class="hljs-comment">        3.初始化:dp[0][0]=0,dp[0][1]=-prices[0],dp[0][2]=-prices[0],dp[0][3]=dp[0][4]=dp[0][5]=0</span><br><span class="hljs-comment">        4.遍历顺序:i正序,j无所谓</span><br><span class="hljs-comment">        5.返回形式:返回max(dp[len-1][3],dp[len][4],dp[len-1][5])</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">6</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">5</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>            dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">4</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>            dp[i][<span class="hljs-number">5</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">5</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">5</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-LC714-买卖股票的最佳时机含手续费">2.6 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/"><strong>LC714. 买卖股票的最佳时机含手续费</strong></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        与股票买卖II十分类似,唯一的不同就是要支付手续费,可以看做卖出的时候股票价格减少fee</span><br><span class="hljs-comment">        一共有2种状态:(其中没操作股票归纳到情况1)</span><br><span class="hljs-comment">        状态0:持有股票</span><br><span class="hljs-comment">        状态1:不持有股票</span><br><span class="hljs-comment">        1.状态定义:dp[i][j]代表的第i天处于状态j时的最大身价</span><br><span class="hljs-comment">        2.状态转移:</span><br><span class="hljs-comment">            2.0 持有股票,可能今天刚买或者之前就买了:dp[i][0]=max(dp[i-1][1]-prices[i],dp[i-1][0])</span><br><span class="hljs-comment">            2.1 不持有股票,可能今天刚卖或者之前就卖了:dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]-fee)</span><br><span class="hljs-comment">        3.初始化:初始化dp[0][0]=-prices[0],dp[0][1]=0</span><br><span class="hljs-comment">        4.遍历顺序:i正序,j任意</span><br><span class="hljs-comment">        5.返回形式:返回dp[len-1][1]</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-LC926-将字符串翻转到单调递增">3.<a href="https://leetcode.cn/problems/flip-string-to-monotone-increasing/"><strong>LC926. 将字符串翻转到单调递增</strong></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        动态规划:</span><br><span class="hljs-comment">        翻转后的单调递增字符串可能的情形有:000...000  000...111  111...111</span><br><span class="hljs-comment">        归结起来就是两种情形:以0结尾和以1结尾 分开来考虑转移会更加明确</span><br><span class="hljs-comment">        1.状态定义:f[i][0]为考虑s[0,i]翻转后为以0结尾的s[0,i]为递增序列最少翻转次数</span><br><span class="hljs-comment">                    f[i][1]为考虑s[0,i]翻转后为以1结尾的s[0,i]为递增序列最少翻转次数</span><br><span class="hljs-comment">        2.状态转移:要求f[i][0]与f[i][1]就要看s[i]</span><br><span class="hljs-comment">            2.1 s[i]==0时 f[i][0]=f[i-1][0]  f[i][1]=min(f[i-1][1],f[i-1][0])+1</span><br><span class="hljs-comment">            2.2 s[i]==1时 f[i][1]=min(f[i-1][0],f[i-1][1])  f[i][0]=f[i-1][0]+1</span><br><span class="hljs-comment">        3.初始化:f[0][0]=s[0]==0?0:1  f[0][1]=s[0]==1?0:1</span><br><span class="hljs-comment">        4.遍历顺序:i正序</span><br><span class="hljs-comment">        5.返回形式:返回min(f[n-1][0],f[n-1][1]) 最后被翻转成0或者1结尾都有可能使得翻转次数最少</span><br><span class="hljs-comment">        时间复杂度:O(N)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] chs = s.toCharArray();<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = chs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = chs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (chs[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                f[i][<span class="hljs-number">0</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>                f[i][<span class="hljs-number">1</span>] = Math.min(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f[i][<span class="hljs-number">0</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>                f[i][<span class="hljs-number">1</span>] = Math.min(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(f[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-LC2320-统计放置房子的方式数">4.<a href="https://leetcode.cn/problems/count-number-of-ways-to-place-houses/"><strong>LC2320. 统计放置房子的方式数</strong></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        状态机DP问题(有更加简单的做法，这里为了演示状态机DP):</span><br><span class="hljs-comment">        1.状态定义:</span><br><span class="hljs-comment">            1.1 f[i][0]为考虑两边[0,i]的地方i位置上下都不放置房子的方案数</span><br><span class="hljs-comment">            1.2 f[i][1]为考虑两边[0,i]的地方i位置只放上面的地方</span><br><span class="hljs-comment">            1.3 f[i][2]为考虑两边[0,i]的地方i位置只放下面的地方</span><br><span class="hljs-comment">            1.4 f[i][3]为考虑两边[0,i]的地方i位置上下都放置房子的方案数</span><br><span class="hljs-comment">        2.状态转移:考虑i位置一共有4种状态,根据实际转移即可</span><br><span class="hljs-comment">            f[i][0]=f[i-1][3]+f[i-1][2]+f[i-1][1]+f[i-1][0]</span><br><span class="hljs-comment">            f[i][1]=f[i-1][2]+f[i-1][0]</span><br><span class="hljs-comment">            f[i][2]=f[i-1][1]+f[i-1][0]</span><br><span class="hljs-comment">            f[i][3]=f[i-1][0]</span><br><span class="hljs-comment">        3.初始化:f[0][0]=f[0][1]=f[0][2]=f[0][3]=1</span><br><span class="hljs-comment">        4.遍历顺序:i正序</span><br><span class="hljs-comment">        5.返回形式:最后4种情形加起来就是答案sum(f[n-1][j])</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-type">long</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n][<span class="hljs-number">4</span>];<br>        Arrays.fill(f[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            f[i][<span class="hljs-number">0</span>] = (f[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;<br>            f[i][<span class="hljs-number">1</span>] = (f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;<br>            f[i][<span class="hljs-number">2</span>] = (f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;<br>            f[i][<span class="hljs-number">3</span>] = (f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> ff : f[n - <span class="hljs-number">1</span>]) &#123;<br>            res = (res + ff) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-LC552-学生出勤记录-II">5.<a href="https://leetcode.cn/problems/student-attendance-record-ii/"><strong>LC552. 学生出勤记录 II</strong></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkRecord</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        动态规划:</span><br><span class="hljs-comment">        按 总出勤 计，学生缺勤（&#x27;A&#x27;）严格 少于两天。</span><br><span class="hljs-comment">        那么可以将情况分为两种:0天或者1天A</span><br><span class="hljs-comment">        其中，1天的可以枚举A出现的天数，然后两边通过乘法原理进行求解次数</span><br><span class="hljs-comment">            0天的可以通过动态规划进行求解，因为只有L与P两种状态，合法情况为最多两个连续的L</span><br><span class="hljs-comment">        1.状态定义:由于第i天（从1开始）的选择被前两天i-1与i-2限制了，因此会多出两个维度f[i][pre][cur]</span><br><span class="hljs-comment">            因此定义f[i][0][0]为第i-1与i天选择为LL的情形数，f[i][0][1]为第i-1与i天选择为LP的情形数</span><br><span class="hljs-comment">                f[i][1][0]为第i-1与i天选择为PL的情形数，f[i][1][1]为第i-1与i天选择为PP的情形数</span><br><span class="hljs-comment">        2.状态转移:显然f[i][0][0]=f[i-1][1][0]，f[i][0][1]=f[i-1][0][0]+f[i-1][1][0]</span><br><span class="hljs-comment">                f[i][1][0]=f[i-1][0][1]+f[i-1][1][1]，f[i][1][1]=f[i-1][1][1]+f[i-1][0][1]</span><br><span class="hljs-comment">        3.初始化:f[2][0][0]=1，f[2][1][0]=1，f[2][0][1]=1，f[2][1][1]=1</span><br><span class="hljs-comment">        4.遍历顺序:i正序，其余任意</span><br><span class="hljs-comment">        5.返回形式:∑f[n][pre][cur]+有1个A的情形数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">long</span>[][][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        f[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            f[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = (f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;<br>            f[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = (f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;<br>            f[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = (f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-comment">// sum[i]表示长度为i天数不包含A的合法情形数</span><br>        <span class="hljs-type">long</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        sum[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 没有天数视为1</span><br>        sum[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            sum[i] = (f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + f[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + f[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + f[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-comment">// System.out.println(Arrays.toString(sum));</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> sum[n];<br>        <span class="hljs-comment">// 统计带A的合法情形数，其中i为A出现的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            res = (res + (sum[i - <span class="hljs-number">1</span>] * sum[n - i]) % MOD) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态机DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维前缀和专题</title>
      <link href="/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%93%E9%A2%98.html"/>
      <url>/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p><strong>二维前缀和模板：</strong></p><p><strong>一维前缀和:sum[i,j]=sum[j+1]-sum[i]</strong></p><p>将sum[i][j]看成是以 <strong>matrix[0][0]</strong> 为左上角顶点, <strong>matrix[i-1][j-1]</strong> 为右下角顶点的矩阵内所有元素的和</p><p><strong>初始化sum矩阵</strong>：sum[i + 1][j + 1] = sum[i][j + 1] + sum[i + 1][j] - sum[i][j] + matrix[i][j];</p><p><img src="../images/p21.jpg" alt="p21"></p><p><strong>区块求和:</strong> sumRegion(r1, c1, r2, c2)=sum[r2 + 1, c2 + 1] - sum[r1, c2 + 1] - sum[r2 + 1, c1] + sum[r1, c1]</p><p><img src="../images/p22.jpg" alt="p22"></p><p>也就是数说sum[i][j]是比matrix<strong>超前一位</strong>的</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><br>    <span class="hljs-type">int</span>[][] sum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                sum[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = sum[i][j + <span class="hljs-number">1</span>] + sum[i + <span class="hljs-number">1</span>][j] - sum[i][j] + matrix[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 求以(r1,c1)为左上角,(r2,c2)为右下角的区块和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> c1, <span class="hljs-type">int</span> r2, <span class="hljs-type">int</span> c2)</span> &#123;<br>        <span class="hljs-keyword">return</span> sum[r2 + <span class="hljs-number">1</span>][c2 + <span class="hljs-number">1</span>] - sum[r1][c2 + <span class="hljs-number">1</span>] - sum[r2 + <span class="hljs-number">1</span>][c1] + sum[r1][c1];<br>    &#125;<br>    <br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口专题</title>
      <link href="/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98.html"/>
      <url>/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p><strong>详见：</strong><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/"><strong>1004. 最大连续1的个数 III - 负雪明烛 的题解</strong></a></p><p><strong>解题思路</strong></p><p><strong>重点：</strong> 题意转换。把「最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度」转换为 「找出一个最长的子数组，该子数组内最多允许有 K 个 0 」。</p><p>经过上面的题意转换，我们可知本题是求最大连续子区间，可以使用滑动窗口方法。滑动窗口的限制条件是：窗口内最多有 K 个 0。</p><p><strong>代码思路：</strong></p><p>1.使用 l 和 r 两个指针，分别指向滑动窗口的左右边界。</p><p>2.<strong>r 主动右移：</strong> r 指针每次移动一步。当nums[r]为 0，说明滑动窗口内增加了一个 0；</p><p>3.<strong>l 被动右移：</strong> 判断此时窗口内 0 的个数，如果超过了 k，则 l 指针被迫右移，直至窗口内的 0 的个数小于等于 k 为止。</p><p>4.<strong>滑动窗口长度最大值</strong>就是所求。</p><p>示例：</p><p>以 A= [1,1,1,0,0,0,1,1,1,1,0], K = 2 为例，下面的动图演示了滑动窗口的两个指针的移动情况。</p><p>见 <a href="https://leetcode.cn/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/"><strong>1004. 最大连续1的个数 III - 负雪明烛 的题解</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">// 窗口中0的个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>; r &lt; n; r++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[r] == <span class="hljs-number">0</span>) zero++; <span class="hljs-comment">// r主动右移形成新的窗口</span><br>        <span class="hljs-comment">// 窗口内的0个数&gt;k代表不符合题意-&gt;此时l应被动移动至符合对应r要求的位置</span><br>        <span class="hljs-keyword">while</span> (zero &gt; k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[l] == <span class="hljs-number">0</span>) zero--;<br>            l++;<br>        &#125;<br>        <span class="hljs-comment">// 维护每一轮r对应的窗口长度最大值就是res</span><br>        res = Math.max(res, r - l + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>分享滑动窗口模板</p><p>《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。</p><p>我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findSubArray(<span class="hljs-type">int</span>[] nums)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> num.length; <span class="hljs-comment">// 数组or字符串长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 双指针，表示当前遍历的区间[l, r]，闭区间</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 用于统计 子数组or子区间 是否有效，根据题目可能会改成求和or计数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 保存最大的满足题目要求的 子数组or子串 长度</span><br>    <span class="hljs-keyword">while</span> (r &lt; n)&#123;     <span class="hljs-comment">// 当右边的指针没有搜索到 数组or字符串 的结尾</span><br>        sum += nums[r]     <span class="hljs-comment">// 增加当前右边指针的数字or字符的求和or计数</span><br>        <span class="hljs-keyword">while</span> 区间[l, r]不符合题意&#123;<br>            sum -= nums[l] <span class="hljs-comment">// 移动左指针前需要从sum中减少l位置字符的求和or计数</span><br>            l++ <span class="hljs-comment">// 真正的移动左指针，注意不能跟上面一行代码写反</span><br>        &#125; <span class="hljs-comment">// 此时需要一直移动左指针，直至找到一个符合题意的区间</span><br>        <span class="hljs-comment">// 到 while 结束时，我们找到了一个符合题意要求的 子数组or子串</span><br>        res = Math.max(res, r - l + <span class="hljs-number">1</span>) <span class="hljs-comment">// 需要更新结果</span><br>        r++ <span class="hljs-comment">// 移动右指针，去探索新的区间</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</strong></p><p><strong>模板的整体思想是：</strong></p><p>1.定义两个指针 l 和 r 分别指向区间的开头和结尾，注意是闭区间；定义 sum 用来统计该区间内的各个字符出现次数；</p><p>2.第一重 while 循环是为了判断 r 指针的位置是否超出了数组边界；当 r 每次到了新位置，需要增加 r 指针的求和/计数；</p><p>3.第二重 while 循环是让 l 指针向右移动到 [l, r] 区间符合题意的位置；当 l 每次移动到了新位置，需要减少 l 指针的求和/计数；</p><p>4.在第二重 while 循环之后，成功找到了一个符合题意的 [l, r] 区间，题目要求最大的区间长度，因此更新 res = max(res, 当前区间的长度) 。</p><p>5.r 指针每次向右移动一步，开始探索新的区间。</p><p>6.模板中的 sum 需要根据题目意思具体去修改，本题是求和题目因此把sum 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sum 。</p><p>7.另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间 [l, r] 不符合题意 。对于本题而言，就是该区间内的 0 的个数 超过了 2 。</p><p><strong>滑窗题目主要有两种类型：</strong></p><p>1.窗口大小固定，例如为10，这时候相当于左右边界必定严格同步移动。</p><p>2.左指针l不回退类型，这类型一般是新加入nums[r]使得回退必定不符合条件，旧的nums[r]已经不符合条件，这种也可以利用滑窗的思想求解。</p><p><strong>再来一道练习题：</strong></p><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/"><strong>LC209. 长度最小的子数组</strong></a></p><p>给定一个含有n个正整数的数组和一个正整数<code>target</code> 。<br>找出该数组中满足其和<code>≥ target</code> 的长度最小的连续子数组<code>〔numsl，numsl+1，...，numsr-1,numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回0。<br><strong>示例1:</strong><br>输入： target = 7, nums = [2,3,1,2,4,3] 输出：2<br>解释：子数组[4,3]是该条件下的长度最小的了教组。<br><strong>示例2:</strong><br>输入： target = 4，nums = [1,4,4] 输出：1<br><strong>示例3:</strong><br>输入： target = 11，nums = [1,1,1,1,1,1,1,1] 输出：0</p><p><strong>思路：</strong></p><p><strong>滑动窗口</strong>:</p><p>这一题最关键的字眼&quot;<strong>≥ target 的长度最小的 连续子数组</strong>&quot;</p><p>这个字眼可以联想到很多东西</p><p>1.<strong>连续</strong>子数组：是连续的，因此可以与<strong>前缀和</strong>进行结合（实际上sum变量是一种对于前缀和的优化写法，目的是快速计算窗口的和）</p><p>同时，连续子数组，<strong>左右指针</strong>为边界就可以确定一个连续子数组-&gt;<strong>滑动窗口</strong></p><p>因此这一题的的提示已经非常明确了，必定是用滑窗</p><p>2.长度最小：一般来说求最小长度这种全局最优状态，可以考虑<strong>动态规划</strong>或者<strong>一路维护</strong></p><p>这里用dp的话，状态就是nums[i]结尾的最大长度，显然不太合适，dp[i-1]与dp[i]没有很明显的联系</p><p>那么就需要一路维护，求出<strong>以nums[r]为右边界的窗口的最小长度，r∈[0,len-1]</strong></p><p>维护好nums[0]~nums[len-1]为右边界的合法窗口长度，就是全局的合法窗口最小值，也就是所求！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 滑窗:右指针主动右移,左指针被动右移</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 维护当前窗口[l,r]的总和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 主动移动右指针</span><br>        <span class="hljs-keyword">for</span> (; r &lt; len; r++) &#123;<br>            <span class="hljs-comment">// 计算当前窗口[l,r]的和:新加入的元素只有nums[r]</span><br>            <span class="hljs-comment">// r指针可能要循环多次才能找到符合条件的[l,r],因为l右移至不符合sum&gt;=target</span><br>            sum += nums[r];<br>            <span class="hljs-comment">// 若窗口[l,r]满足条件,统计长度并尝试将其尽可能缩小,直至不符合题意</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                <span class="hljs-comment">// [l,r]符合条件,维护res</span><br>                res = Math.min(res, r - l + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// l一直右移并统计,直至不满足条件</span><br>                <span class="hljs-comment">// 这里有个很值得思考的点:为什么l指针可以义无反顾地移动至不符合条件的l+1?</span><br>                <span class="hljs-comment">// [l,r]合法;[l+1,r]不合法,而[l,r+1]及更长的不可能被统计因为只统计短的</span><br>                <span class="hljs-comment">// [l,r-1]以及更短的呢?右边界为r-1的情况已统计,因为l会直接移动到不合法且nums都为正数,因此窗口不可能继续缩小!</span><br>                <span class="hljs-comment">// 所以此时l可以义无反顾地移动至l+1</span><br>                sum -= nums[l++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若没有窗口符合条件就是0</span><br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么l指针可以义无反顾地移动至不符合条件的l+1?滑窗精髓所在-&gt;减少不必要的计算</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑窗 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩DP专题</title>
      <link href="/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP%E4%B8%93%E9%A2%98.html"/>
      <url>/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p><strong>两道入门题目：</strong></p><h3 id="1-2305-公平分发饼干">1.<a href="https://leetcode.cn/problems/fair-distribution-of-cookies/"><strong>2305. 公平分发饼干</strong></a></h3><p>1.状态定义:<strong>dp[i][j]</strong> 为第 <strong>i</strong>个孩子分饼干状态为 <strong>j</strong> 时每个孩子能分到的最多饼干数的最小值</p><p>2.状态转移:要求得<strong>dp[i][j]</strong> 的值，要考虑 <strong>j</strong> 的每个子集，再维护 子集计算出的最大值然后转移过来 <strong>最小值</strong></p><p>​      <strong>dp[i][j]=min(max(dp[i-1][j-x],sum[x]))</strong> 其中sum[x]为分配状态为 <strong>x</strong> 时的总的糖果数</p><p>3.初始化:<strong>dp[0][j]=sum[j]</strong>，只分给第一个孩子肯定是全分了总数就是饼干数<strong>sum[j]</strong>，其余为 <strong>INF</strong> 方便覆盖</p><p>4.遍历顺序:先i后j最后x,正序</p><p>5.返回形式:返回 <strong>dp[n-1][mask-1]</strong> 即 所有孩子将饼干全部分完时<strong>每个孩子最大饼干数的最小值</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCookies</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cookies, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cookies.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; n;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k][mask];<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mask];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; mask; i++) &#123;<br>            <span class="hljs-comment">// x为获取的最低位1后面尾随0个数，y为缺位x的差集</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.numberOfTrailingZeros(i), y = i - (<span class="hljs-number">1</span> &lt;&lt; x);<br>            sum[i] = sum[y] + cookies[x];<br>        &#125;<br>        <span class="hljs-comment">// 初始化</span><br>        System.arraycopy(sum, <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, mask);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; i++) &#123;<br>            Arrays.fill(dp[i], <span class="hljs-number">0x3f3f3f3f</span>);<br>        &#125;<br>        <span class="hljs-comment">// 遍历状态</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mask; j++) &#123;<br>                <span class="hljs-comment">// 此时j-x就是枚举j的所有子集</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> j; x != <span class="hljs-number">0</span>; x = (x - <span class="hljs-number">1</span>) &amp; j) &#123;<br>                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - <span class="hljs-number">1</span>][j - x], sum[x]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k - <span class="hljs-number">1</span>][mask - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1723-完成所有工作的最短时间">2.<a href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/"><strong>1723. 完成所有工作的最短时间</strong></a></h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTimeRequired</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> jobs.length;    <span class="hljs-comment">// n为工作份数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; n;  <span class="hljs-comment">// 工作分配情况数目</span><br>        <span class="hljs-comment">// dp[i][j]表示考虑索引为[0,i]的工人,工作分配情况为j(01010...表示)时每个工人最大工作时间的最小值</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k][mask];<br>        <span class="hljs-comment">// 初始化sum[i] -&gt; 完成状态为i的工作的总时间</span><br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mask];<br>        <span class="hljs-comment">// i∈[1,mask-1] 因为sum[0]=0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; mask; i++) &#123;<br>            <span class="hljs-comment">// x为i最低位1后面的尾随0个数,y为与i相比仅仅缺位x位置的状态</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.numberOfTrailingZeros(i), y = i - (<span class="hljs-number">1</span> &lt;&lt; x);<br>            sum[i] = sum[y] + jobs[x];  <span class="hljs-comment">// 加上缺位的x就是i的时长</span><br>        &#125;<br>        <span class="hljs-comment">// 初始化dp</span><br>        System.arraycopy(sum, <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, mask);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; i++) &#123;<br>            Arrays.fill(dp[i], <span class="hljs-number">0x3f3f3f3f</span>);<br>        &#125;<br>        <span class="hljs-comment">// 遍历dp状态</span><br>        <span class="hljs-comment">// 遍历每个工人i</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-comment">// 遍历每种状态j</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mask; j++) &#123;<br>                <span class="hljs-comment">// 遍历状态j的每种子集j-x</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> j; x != <span class="hljs-number">0</span> ; x = (x - <span class="hljs-number">1</span>) &amp; j) &#123;<br>                    <span class="hljs-comment">// 找到每种子集j-x得到的最大值转移过来的 最小值 就是考虑[0,i]工人,状态为j-x的最大工作时间的最小值</span><br>                    <span class="hljs-comment">// 子集转移途径为:取前面dp[i - 1][j - x]最大值的最小值与分配给工人i的sum[x]进行比较找到最大值</span><br>                    <span class="hljs-comment">// 再维护每种转移途经最小值</span><br>                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - <span class="hljs-number">1</span>][j - x], sum[x]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 所有工人分配完所有工作的最长单人工作时间最小值</span><br>        <span class="hljs-keyword">return</span> dp[k - <span class="hljs-number">1</span>][mask - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们不妨来总结一下状态压缩DP：其实状态压缩DP是类似于暴力法回溯的方法，能用状态压缩方法做的通常都可以用回溯+剪枝来求解。一般来说这种问题称为“分配问题”，或者叫做“桶轮询”。就是将元素(通常数目很小&lt;32个)分配到多个容器(桶)中，然后求解有每个桶最多数目的最少值，或者是满足条件路径数等，这里求解目标的不同体现在转移方程上。</p><p>抽象一下：饼干、工作（要分配的对象）——<strong>元素</strong>；工人、孩子（被分配到的地方）——<strong>容器（桶）</strong></p><p><a href="https://leetcode.cn/problems/beautiful-arrangement/">526. 优美的排列</a> 这道题就是要求路径数目，同时将桶容量限制为1，因此子集数目只有 i 个</p><h3 id="3-总体模板（本质也是DP）：">3.总体模板（本质也是DP）：</h3><p>1.状态定义：dp[i][i]为考虑前 <strong>i</strong> 个容器（桶），分配状态为 <strong>j</strong> (0101表示分配状态)时候的 所求量（路径数、最大值、最小值等）</p><p>2.状态转移：此时遍历到第 <strong>i</strong> 个容器（桶），一般来说要求 <strong>dp[i][j]</strong> 得考虑前面容器的情况 -&gt; <strong>dp[i-1][j-x]</strong></p><p>其中 <strong>x</strong> 为第 <strong>i</strong> 个容器的选择状态，那么 <strong>j-x</strong> 就是 <strong>[0,i-1]</strong> 个容器的选择状态</p><p>将第<strong>i</strong>个容器独立出来考虑，这个容器的选择有哪些？也就是转移路径有哪些？？？</p><p>很显然如果桶的容量（包括元素个数与总和）没有限制的话，<strong>j</strong> 的全体子集（除了本身）都是符合要求的前一个状态</p><p>-&gt; 因此可以直接通过下面语句枚举 <strong>j</strong> 的所有合法子集来进行 dp[i][j] 状态转移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> j; x != <span class="hljs-number">0</span> ; x = (x - <span class="hljs-number">1</span>) &amp; j) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - x]... <span class="hljs-comment">// 搭建两个状态的桥梁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>-&gt; 当然也有可能<strong>容量有限</strong>：参考 <a href="https://leetcode.cn/problems/beautiful-arrangement/">526. 优美的排列</a> 枚举符合条件的子集（合法转移路径）进行转移即可</p><p>3.初始化：一般来说，初始化 <strong>dp[0][j]</strong> 为首个容器分得状态 <strong>j</strong> 时的所求量；其他<strong>dp[i][j]</strong> 按照转移逻辑来初始化</p><p>目的都是要作为初始哨兵不影响第一个值的覆盖（如求最大值就弄个很小的数第一个比较的必定顺利覆盖…）</p><p>4.遍历顺序：一般是先遍历容器 <strong>i</strong> ，再遍历每个状态 <strong>j</strong> ，最后遍历每种合法转移路径 <strong>j-x</strong>，默认正序</p><p>5.返回形式：一般返回 <strong>dp[n-1][mask-1]</strong> 表示考虑所有桶，把所有元素分配完的所求量为多少</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有向图的表示方法</title>
      <link href="/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.html"/>
      <url>/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>约定 <strong>n</strong> 为点数， <strong>m</strong>为边数，times = [[2,1,1],[2,3,1],[3,4,1]] 表示3条边</p><p>2-&gt;1 权重为1</p><p>2-&gt;3 权重为1</p><p>3-&gt;4 权重为1</p><h3 id="1-邻接矩阵">1.邻接矩阵</h3><p>这是一种使用二维矩阵来进行存图的方式。</p><p>适于边数较多的「<strong>稠密图</strong>」使用，当边数量接近点的数量的平方，即m≈n²时，可定义为「<strong>稠密图</strong>」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 邻接矩阵数组：w[a][b] = c 代表从 a 到 b 有权重为 c 的边</span><br><span class="hljs-type">int</span>[][] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br><br><span class="hljs-comment">// 加边操作</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>    w[a][b] = c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-邻接表-链式前向星存图">2.邻接表(链式前向星存图)</h3><p>适用于边数较少的「<strong>稀疏图</strong>」使用，当边数量接近点的数量，即m≈n 时，可定义为「<strong>稀疏图</strong>」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] he = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M], ne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M], w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M];<br><span class="hljs-type">int</span> idx;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>    e[idx] = b;    <span class="hljs-comment">// 边idx指向节点b</span><br>    ne[idx] = he[a];    <span class="hljs-comment">// 头插法在上一轮的a射出的边的头结点上插入idx</span><br>    he[a] = idx;    <span class="hljs-comment">// 更新a射出的边的头结点为边idx</span><br>    w[idx] = c;    <span class="hljs-comment">// 边idx的权重为c</span><br>    idx++;        <span class="hljs-comment">// 边索引+1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先 idx 是用来对<strong>边</strong>进行编号的：</p><p>1.he 数组：存储是某个节点所对应的<strong>边的集合</strong>（链表）的头结点；</p><p>如下图所示：he[u]=边4</p><p>注意：<strong>仅仅是存储头结点</strong>，之后就可以根据ne数组进行查找！</p><p><img src="../images/p20.jpg" alt="p20"></p><p>2.e  数组：<strong>某一条边指向的节点</strong>：e[边4]=v4</p><p><a href="http://3.ne">3.ne</a> 数组：由于是以链表的形式进行存边，该数组用于<strong>找到下一条边</strong></p><p>ne[边4]=边3；构建链表的过程是头插法：null&lt;-边1&lt;-边2…</p><p>4.w  数组：用于记录<strong>某条边的权重</strong>为多少。</p><p>编码的边是用idx作为索引来进行标记的，也就是说每一个idx对应一条边</p><p>因此当我们想要<strong>遍历所有由 a 点发出的边（注意是a伸出的边）</strong> 时，可使用如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从a射出的边的头结点出发一路遍历至-1(null)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> he[a]; i != -<span class="hljs-number">1</span>; i = ne[i]) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> e[i], c = w[i]; <span class="hljs-comment">// 存在由 a 指向 b 的边，权重为 c</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-类">3.类</h3><p>这是一种最简单，但是相比上述两种存图方式，使用得较少的存图方式。</p><p>只有当我们需要确保某个操作复杂度严格为<strong>O(m)</strong> 时，才会考虑使用。</p><p>具体的，我们建立一个类来记录有向边信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-comment">// 代表从 a 到 b 有一条权重为 c 的边</span><br>    <span class="hljs-type">int</span> a, b, c;<br>    Edge(<span class="hljs-type">int</span> _a, <span class="hljs-type">int</span> _b, <span class="hljs-type">int</span> _c) &#123;<br>        a = _a; b = _b; c = _c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常我们会使用 List 存起所有的边对象，并在需要遍历所有边的时候，进行遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Edge&gt; es = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>...<br><span class="hljs-keyword">for</span> (Edge e : es) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-HashMap">4.HashMap</h3><p>注意：如果节点索引集中可以用List数组代替HashMap，具体参考List数组创建与初始化方法</p><p>key为出发点，value为该出发点对应的终点列表（一个出发点可能对应多个终点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>    List&lt;Integer&gt; list1 = map.getOrDefault(edge[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    list1.add(edge[<span class="hljs-number">1</span>]);<br>    map.put(edge[<span class="hljs-number">0</span>], list1);<br>    <span class="hljs-comment">// 若为无向图</span><br>    List&lt;Integer&gt; list2 = map.getOrDefault(edge[<span class="hljs-number">1</span>], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    list2.add(edge[<span class="hljs-number">0</span>]);<br>    map.put(edge[<span class="hljs-number">1</span>], list2);<br>&#125;<br><br><span class="hljs-comment">// 带权图</span><br>HashMap&lt;Integer, List&lt;<span class="hljs-type">int</span>[]]&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>    List&lt;<span class="hljs-type">int</span>[]&gt; list1 = map.getOrDefault(edge[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]&#125;);<br>    map.put(edge[<span class="hljs-number">0</span>], list1);<br>    <span class="hljs-comment">// 若为带权无向图</span><br>    List&lt;Integer&gt; list2 = map.getOrDefault(edge[<span class="hljs-number">1</span>], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    list2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">2</span>]&#125;);<br>    map.put(edge[<span class="hljs-number">1</span>], list2);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法专题</title>
      <link href="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98.html"/>
      <url>/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-快速排序">1.快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">62</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">19</span>&#125;;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) System.out.println(num);<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    快速排序:原理每一轮选一个基准元素pivot</span><br><span class="hljs-comment">    利用两个指针分别将&lt;=pivot和&gt;pivot的元素分别放在pivot的左边与右边</span><br><span class="hljs-comment">    最后递归调用原函数直至区间长度缩小为1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//  区间长度&lt;=1直接结束</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> low, r = high;  <span class="hljs-comment">// 左右指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[low];  <span class="hljs-comment">// 以nums[low]为基准</span><br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-comment">// r指针先行可以确保最后停留的位置必定是&lt;=基准，再不济就移动到pivot位置上；而l指针先行会找到首个大于基准的位置</span><br>        <span class="hljs-comment">// 例如在[1,2,3,4,5]这种情况会停在2处，此时r指针想找小于等于基准的元素但是也只能移动到2处结束</span><br>        <span class="hljs-comment">// 循环退出-&gt;将1与2的位置交换，此时有[2,1,3,4,5] 这个就违反了快排的宗旨了，再递归左右子区间就出错。</span><br>        <span class="hljs-comment">// 归根到底右指针先行，是为了避免左指针主动时导致停留在比基准大的地方，与基准交换后直接导致基准左边有元素大于基准。</span><br>        <span class="hljs-comment">// 右指针先行会主动占据&lt;=基准的元素，再不济就是移动到基准位置，这两种情况符合快排目的.</span><br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt; pivot) r--;  <span class="hljs-comment">// r停留在首个&lt;=基准的元素处</span><br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= pivot) l++;  <span class="hljs-comment">// l停留在首个&gt;基准的元素处</span><br>        <span class="hljs-keyword">if</span> (l &lt; r) &#123;    <span class="hljs-comment">// 交换nums[l]与nums[r]</span><br>            <span class="hljs-comment">// nums[l] ^= nums[r];</span><br>            <span class="hljs-comment">// nums[r] ^= nums[l];</span><br>            <span class="hljs-comment">// nums[l] ^= nums[r];</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[l];<br>            nums[l] = nums[r];<br>            nums[r] = t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// l == r 将nums[low]与nums[l]交换</span><br>    nums[low] = nums[l];<br>    nums[l] = pivot;<br>    <span class="hljs-comment">// 递归排序左右子区间</span><br>    quickSort(nums, low, r - <span class="hljs-number">1</span>);<br>    quickSort(nums, r + <span class="hljs-number">1</span>, high);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-归并排序">2.归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Merge_Sort</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">62</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">19</span>&#125;;<br>        mergeSort(nums);<br>        System.out.println(Arrays.toString(nums));<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    归并排序:分区间排序+合并两个有序数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    重载的带区间端点的归并排序方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span>[] tmp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        mergeSort(nums, l, mid, tmp);   <span class="hljs-comment">// 递归排序[l,mid]</span><br>        mergeSort(nums, mid + <span class="hljs-number">1</span>, r, tmp);   <span class="hljs-comment">// 递归排序[mid+1,r]</span><br>        <span class="hljs-comment">// 合并两个有序数组[l,mid]和[mid+1,r]</span><br>        merge(nums, l, mid, r, tmp);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    合并nums两个区间内的两个有序数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span>[] tmp)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> l;    <span class="hljs-comment">// 合并后的指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左右指针</span><br>        <span class="hljs-comment">// 将[l,mid]和[mid+1,r]元素按照大小拷贝到tmp对应位置中</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;    <span class="hljs-comment">// 等于的时候还没赋值!</span><br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>                tmp[idx++] = nums[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp[idx++] = nums[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 走完还没有走完的一边</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[idx++] = nums[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= r) tmp[idx++] = nums[j++];<br>        <span class="hljs-comment">// 将临时数组拷贝至nums对应位置</span><br>        System.arraycopy(tmp, l, nums, l, r - l + <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-堆排序">3.堆排序</h3><p>堆是具有以下性质的完全二叉树：每个结点的值都<strong>大于</strong>或等于其左右孩子结点的值，称为大顶堆；</p><p>或者每个结点的值都<strong>小于</strong>或等于其左右孩子结点的值，称为小顶堆。如下图：</p><p><img src="../images/p19.jpg" alt="p19"></p><p><strong>参考资料：</strong><a href="https://blog.csdn.net/Javascript_tsj/article/details/124051388"><strong>堆排序（超详细图解 java版）</strong></a></p><p><strong>主要步骤：</strong></p><p>1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆（升序一般用大顶堆）</p><p>2.将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端</p><p>3.重新调整结构,使其满足堆定义，然后继续交换堆顶元素与当前末尾元素</p><p>4.反复执行调整+交换步骤，直到整个序列有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heap</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<br>        HeapSort(nums);<br>        System.out.println(Arrays.toString(nums));<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     堆排序主方法:</span><br><span class="hljs-comment">     一般来说升序排列就构造大顶堆(堆顶最大&amp;&amp;当前节点比左右子节点都大-&gt;但是左右节点的大小没有要求)</span><br><span class="hljs-comment">     堆的索引统一从0开始,因此总的范围在[0,len-1]</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 叶子节点肯定堆的最底层,不用下沉</span><br>        <span class="hljs-comment">// 这里用了一个结论:只下沉非叶子节点间接也上浮了所有叶子节 因此只下沉前半部分即可保证堆有序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;    <span class="hljs-comment">// len÷2-1是首个非叶子结点索引</span><br>            sink(nums, i, len - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 下沉完后整个堆有序 堆顶元素就是最大元素</span><br>        <br>        <span class="hljs-comment">// 注:索引为[0, i]之间为要调整的堆结范围</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            <span class="hljs-comment">// 将堆中最后一个元素与堆顶元素交换,让最大值放到最后</span><br>            swap(nums, <span class="hljs-number">0</span>, i);<br>            <span class="hljs-comment">// 此时堆顶是下面换上去的元素很小,堆结构被破坏了,通过sink()方法让该元素下沉至适合位置</span><br>            <span class="hljs-comment">// 注意此时要把最后一个排除在外,因为nums的最大值已经确定-&gt;此时堆范围变为[0,i-1]</span><br>            sink(nums, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 下沉完之后[0,i-1]又是一个有序的堆</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调整堆方法(在大顶堆中表现为下沉)</span><br><span class="hljs-comment">     * 将指定索引target的元素在[0, end]范围内进行下沉操作至正确位置</span><br><span class="hljs-comment">     * 比较当前节点值与左右子节点最大值,若前节点值小于左右子节点最大值必须下沉(交换)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums   待排序的数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target 下沉目标元素索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end    要调整的堆范围最大索引</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> target;   <span class="hljs-comment">// 下沉指针</span><br>        <span class="hljs-comment">// 若存在左子节点就进入循环(否则表明下沉到底层了)</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span> &lt;= end) &#123;<br>            <span class="hljs-comment">// maxLR为左右子节点最大值对应的索引,初始化为左子节点索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxLR</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果有右子节点 &amp;&amp; 右子节点的值比左子节点大</span><br>            <span class="hljs-keyword">if</span> (maxLR + <span class="hljs-number">1</span> &lt;= end &amp;&amp; nums[maxLR + <span class="hljs-number">1</span>] &gt; nums[maxLR]) &#123;<br>                <span class="hljs-comment">// 更新maxLR的值为右子节点索引</span><br>                maxLR++;<br>            &#125;<br>            <span class="hljs-comment">// 判断 当前节点值 与 左右子节点最大值maxLR 的大小</span><br>            <span class="hljs-comment">// 正确的堆结构应为:当前节点值nums[idx]&gt;=nums[maxLR] 若这里nums[idx]&lt;nums[maxLR]那就要交换了</span><br>            <span class="hljs-keyword">if</span> (nums[idx] &lt; nums[maxLR]) &#123;<br>                <span class="hljs-comment">// 将idx位置与maxLR位置元素进行交换</span><br>                swap(nums, idx, maxLR);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// nums[idx]&gt;=nums[maxLR]表明target元素位置已经正确-&gt;退出</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// idx指针往maxLR方向走</span><br>            idx = maxLR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    交换nums[i]与nums[j]的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 快排 </tag>
            
            <tag> 堆排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间求和专题</title>
      <link href="/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E4%B8%93%E9%A2%98.html"/>
      <url>/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-树状数组-「单点修改-区间查询」：">1.树状数组-&gt;「单点修改 &amp; 区间查询」：</h3><p>先输入一个长度为n的数组nums，有如下两种操作：</p><p>1.输入一个数m，输出数组中下标1~m的前缀和sum[1,m]</p><p>2.对某个指定下标的数进行值的修改</p><p><img src="../images/p10.jpg" alt="p10"></p><p>常规方法：<strong>前缀和</strong>，但是当单点修改的次数增多，前缀和更新耗时O(N)，然后再求sum[1,m]，总体时间复杂度为O(N^2)</p><p>进阶方法：<strong>树状数组和线段树</strong>可以达到单次操作logN级别。平均时间复杂度O(NlogN)</p><p><img src="../images/p11.jpg" alt="p11"></p><p>7=0111=0100+0010+0001=lowBit(7)+lowBit(3)+lowBit(1)</p><p><strong>前置知识</strong>：二进制区间分解lowBit(x)=x^(-x)求出x中仅保留最低位的1的数值，lowBit(7)=0100=4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>概念：树状数组就是一种基于二进制思想的数据结构，基本用途是维护序列的前缀和</strong>。</p><p><strong>对于给定的序列a，设树状数组为c，则c[x]保存序列a的区间[x-lowbit(x)+1,x]中所有数的和</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br></code></pre></td></tr></table></figure><p>主要有以下两个基本操作:</p><p>(1) update，单点修改，修改序列a中的某个元素;</p><p>(2) query，区间查询，查询序列a中区间[1,x]的所有数的和。</p><p><img src="../images/p12.jpg" alt="p12"></p><p><strong>操作1:区间查询query</strong></p><p>树状数组能够完成的是查询前缀和，相减即可得到区间和。</p><p>利用c[x]维护的是序列a中[x-lowbit(x)+1,x]的区间和，然后不断向前寻找即可，时间复杂度为O(logN)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i)) ans += tr[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>操作2:单点修改update</strong></p><p>单点修改更准确的说是“单点增加”，给序列a中的一个数a[x]加上t，然后要更新树状数组c维护的前缀和，只需要不断向上维护c[x]的父亲结点即可，时间复杂度为O(logN)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> u)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt;= n; i += lowbit(i)) tr[i] += u;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：这里都默认索引从1开始</strong></p><p><strong>思考:如何初始化树状数组?</strong></p><p>方法一:输入序列a等价于对a进行单点修改，更新树状数组即可，时间复杂度为O(NlogN)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    add(i, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二:考虑每个结点对父亲结点的贡献，时间复杂度为O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    tr[i] += nums[i];<br>    <span class="hljs-keyword">if</span> (i + lowBit(i) &lt;= n) tr[i + lowBit(i)] += tr[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>三叶姐树状数组模板：</p><p>一篇不错的图解：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/">[树状数组] 详解树状数组, 包含更新查询图解, 秒懂lowbit含义(JAVA 65ms, 68.6MB)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上来先把三个方法写出来</span><br>&#123;<br>    <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br>    <span class="hljs-comment">// 查询前缀和的方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i)) ans += tree[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 在树状数组 x 位置中增加值 u</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 初始化「树状数组」，要默认数组是从 1 开始</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) add(i + <span class="hljs-number">1</span>, nums[i]);<br>&#125;<br><br><span class="hljs-comment">// 使用「树状数组」：</span><br>&#123;   <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]</span><br>        add(i + <span class="hljs-number">1</span>, val - nums[i]); <br>        nums[i] = val;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(r + <span class="hljs-number">1</span>) - query(l);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-线段树「单点修改、区间修改、单点查询、区间查询-但性能不高」">2.线段树「单点修改、区间修改、单点查询、区间查询-&gt;但性能不高」</h3><p><strong>参考资料：</strong><a href="https://mp.weixin.qq.com/s/T3Ds8Eb8mZ5f96NjRFr6WA"><strong>https://mp.weixin.qq.com/s/T3Ds8Eb8mZ5f96NjRFr6WA</strong></a></p><p><strong>以下笔记均参考力扣题解(推荐)：</strong><a href="https://leetcode.cn/problems/range-module/solution/by-jiang-hui-4-tu5a/">Range模块【线段树动态开点+线段树图解】</a></p><p><strong>什么是线段树？</strong></p><p>线段树其实是一种二叉搜索树，将一个大的区间划分为一个个单元区间。</p><p>内个单元区间表示成一个节点(<strong>单元区间-&gt;节点</strong>) 线段树中的线段，其实也是区间的意思，就是区间树</p><p>假设我们有一个数组为[1,2,3,4,5,6,7,8]，我们表示为一个区间和线段树就是下图：</p><p><img src="../images/p13.jpg" alt="p13"></p><p>可见线段树的区间是按照区间的中点进行分叉，左子节点的区间必定小于右子节点的区间，同理左右子树均是BST</p><p><strong>构建线段树代码（val基于区间求和）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Fomalhaut</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/22</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 线段树模板(今天一定一定要写出来!!!!!)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br>    <span class="hljs-comment">// 用节点数组表示的线段树</span><br>    Node[] tree;<br>    <span class="hljs-comment">// 原始数据</span><br>    <span class="hljs-type">int</span>[] data;<br><br>    <span class="hljs-comment">// 初始化线段树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SegmentTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;   <span class="hljs-comment">// 载入数据</span><br>        <span class="hljs-built_in">this</span>.tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">4</span> * data.length];  <span class="hljs-comment">// 节点个数统一开4*N个</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        线段树节点类</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> left;   <span class="hljs-comment">// (该节点对应的)区间左端点</span><br>        <span class="hljs-type">int</span> right;  <span class="hljs-comment">// 区间右端点</span><br>        <span class="hljs-type">int</span> lazy;   <span class="hljs-comment">// 懒标记</span><br>        <span class="hljs-type">int</span> val;    <span class="hljs-comment">// 节点值(根据不同的问题意义不同)</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    根据区间左右边界[l,r]来构建线段树:idx表示线段树的节点索引,l与r分别表示区间左右边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        tree[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(); <span class="hljs-comment">// 创建idx位置的节点</span><br>        tree[idx].left = l; <span class="hljs-comment">// 该节点左边界为l</span><br>        tree[idx].right = r;    <span class="hljs-comment">//该节点右边界为r</span><br>        <span class="hljs-comment">// base case:到达叶子结点直接赋值</span><br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            tree[idx].val = data[r - <span class="hljs-number">1</span>];    <span class="hljs-comment">// 因为idx从1开始,区间的l与r也是从1开始,但是data索引从0开始,因此向左偏移1位</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// [l,r]区间中点</span><br>        <span class="hljs-comment">// 递归构建左右子树:当idx索引从1开始时,idx*2为左子节点,idx*2+1为右子节点</span><br>        build(idx * <span class="hljs-number">2</span>, l, mid); <span class="hljs-comment">// 左子节点区间范围[l,mid] 左子节点个数&gt;=右子节点</span><br>        build(idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r); <span class="hljs-comment">// 右子节点区间范围[mid+1,r]</span><br>        tree[idx].val = tree[idx * <span class="hljs-number">2</span>].val + tree[idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].val;  <span class="hljs-comment">// 更新idx节点的值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>懒标记的引入：</strong></p><p><img src="../images/p14.jpg" alt="p14"></p><p>如果是线段树，我们直接对根节点的值进行+(8-1+1)*1的操作就可以得到新的区间和，但是这样当我们查询中间某段区间的和时就会发现不对，因为这个+(8-1+1)*1没有涉及根节点的区间和操作！</p><p>于是就想可不可以在root处引入一个标记的量，在我们要下探到要求root子区间的区间和时可以把这个+1操作带下去？把子区间进行更新？于是就引入了<strong>lazy字段</strong></p><p><strong>注意：</strong> 我们只有在用到没有更新的区间时（也就是当前区间含有lazy），才会下传lazy，达到懒更新的目的。</p><p><img src="../images/p15.jpg" alt="p15"></p><p><img src="../images/p16.jpg" alt="p16"></p><p>也许我们还会更新[5,8]区间的值，我们除了设置lazy字段外，<strong>还需要将结果上传到他的父节点</strong>！（很显然，下面变了，上面区间包含下面也要变）</p><p><img src="../images/p17.jpg" alt="p17"></p><p><img src="../images/p18.jpg" alt="p18"></p><p><strong>更新与查询代码如下（非动态开点）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">更新某个区间的值:idx为节点索引,[l,r]为要更新的区间,val代表要更新进去的值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-comment">// idx节点区间在要修改的[l,r]区间里面-&gt;直接更新到这里并并进行懒标记即可</span><br>    <span class="hljs-keyword">if</span> (tree[idx].left &gt;= l &amp;&amp; tree[idx].right &lt;= r) &#123;<br>        <span class="hljs-comment">// idx节点值 += val * idx节点区间的的节点数</span><br>        <span class="hljs-comment">// 意思就是更新了idx节点的整个区间,节点值就加上相应的数</span><br>        tree[idx].val += (tree[idx].right - tree[idx].left + <span class="hljs-number">1</span>) * val;<br>        <span class="hljs-comment">// 对idx节点进行懒标记</span><br>        tree[idx].lazy = val;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 结束</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (tree[idx].lazy != <span class="hljs-number">0</span>) pushDown(idx); <span class="hljs-comment">// 当前节点有懒标记-&gt;下沉懒标记</span><br>    <span class="hljs-comment">// [l,r]与idx节点左区间有交集</span><br>    <span class="hljs-keyword">if</span> (l &lt;= tree[idx * <span class="hljs-number">2</span>].right) update(idx * <span class="hljs-number">2</span>, l, r, val);<br>    <span class="hljs-comment">// [l,r]与idx节点右区间有交集</span><br>    <span class="hljs-keyword">if</span> (r &gt;= tree[idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].left) update(idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r, val);<br>    <span class="hljs-comment">// 底下递归完成后向上回溯更新idx的值</span><br>    pushUp(idx);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">查询区间[l,r]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// idx节点的区间被[l,r]完全包含 -&gt; 直接返回节点值</span><br>    <span class="hljs-keyword">if</span> (tree[idx].left &gt;= l &amp;&amp; tree[idx].right &lt;= r) <span class="hljs-keyword">return</span> tree[idx].val;<br>    <span class="hljs-comment">// 否则就还要继续往下走更小的区间</span><br>    <span class="hljs-comment">// 遇到有懒标记也要下沉(因为你现在要查询小区间的信息)</span><br>    <span class="hljs-keyword">if</span> (tree[idx].lazy != <span class="hljs-number">0</span>) pushDown(idx);<br>    <span class="hljs-comment">// 跟左右区间有交集</span><br>    <span class="hljs-keyword">if</span> (tree[idx * <span class="hljs-number">2</span>].right &gt;= l) res += query(idx * <span class="hljs-number">2</span>, l, r);  <span class="hljs-comment">// 累加递归完成的值</span><br>    <span class="hljs-keyword">if</span> (tree[idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].left &lt;= r) res += query(idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回结果</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">上传结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> &#123;<br>    tree[idx].val = tree[idx * <span class="hljs-number">2</span>].val + tree[idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].val;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">下沉懒标记</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushDown</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-comment">// 向左右子节点下沉lazy(累加而不是覆盖)</span><br>    tree[idx * <span class="hljs-number">2</span>].lazy += tree[idx].lazy;<br>    tree[idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].lazy += tree[idx].lazy;<br>    <span class="hljs-comment">// idx节点区间的中点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> tree[idx].left + (tree[idx].right - tree[idx].left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 左右子节点的节点值分别加上(懒标记的值*区间节点个数)</span><br>    tree[idx * <span class="hljs-number">2</span>].val += tree[idx].lazy * (mid - tree[idx].left + <span class="hljs-number">1</span>);<br>    tree[idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].val += tree[idx].lazy * (tree[idx].right - mid);<br>    <span class="hljs-comment">// 下沉了lazy后idx的懒标记置0</span><br>    tree[idx].lazy = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>动态开点的引入：</strong></p><p>上述代码只是针对不对区间长度进行修改，只能在固定的区间内查询和修改，并且用到了4n的空间，有些空间根本没有被使用，有的题目数据规模到了1e9，如果我们开4n的空间并不可行！</p><p>于是我们需要动态地进行节点创建，即我们不用idx * 2和idx* 2 + 1来表示节点的左右子节点，而是在Node里添加leftChild和rightChild两个引用，来找到左右节点。由于我们是在更新与查询中进行动态开点，所以不需要build树！</p><p><strong>动态开点的代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Fomalhaut</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/23</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 线段树(动态开点+懒标记)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree_Dynamic</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    动态开点线段树节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> left, right;    <span class="hljs-comment">// 区间左右端点</span><br>        <span class="hljs-type">int</span> val;    <span class="hljs-comment">// 节点的值</span><br>        <span class="hljs-type">int</span> lazy;   <span class="hljs-comment">// 懒标记:0代表没有懒标记</span><br>        Node leftChild, rightChild; <span class="hljs-comment">// 左右子树引用</span><br><br>        <span class="hljs-comment">// 根据区间[left,right]创建节点</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    动态开点的区间更新:root代表根节点,[l,r]代表更新区间,val代表更新的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Node root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 1.[l,r]不在root区间的范围内 -&gt; 直接返回</span><br>        <span class="hljs-keyword">if</span> (r &lt; root.left || l &gt; root.right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 2.[l,r]包含root区间 -&gt; 进行懒标记并更新root的值</span><br>        <span class="hljs-keyword">if</span> (root.left &gt;= l &amp;&amp; root.right &lt;= r) &#123;<br>            root.lazy = val;    <span class="hljs-comment">// 进行懒标记</span><br>            root.val += (root.right - root.left + <span class="hljs-number">1</span>) * val; <span class="hljs-comment">// 节点值+=区间长度*val</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3.继续往下走</span><br>        lazyCreate(root);   <span class="hljs-comment">// 动态开点</span><br>        pushDown(root); <span class="hljs-comment">// 下传lazy</span><br>        update(root.leftChild, l, r, val);  <span class="hljs-comment">// 更新左子树区间</span><br>        update(root.rightChild, l, r, val); <span class="hljs-comment">// 更新右子树区间</span><br>        pushUp(root);   <span class="hljs-comment">// 上传结果</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    动态开点的查询区间[l,r]</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(Node root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-comment">// [l,r]必定在root里面,因为root是最大的可能区间</span><br>        <span class="hljs-comment">// 1.root的区间在[l,r]里面 -&gt; 直接返回节点值</span><br>        <span class="hljs-keyword">if</span> (root.left &gt;= l &amp;&amp; root.right &lt;= r) <span class="hljs-keyword">return</span> root.val;<br>        <span class="hljs-comment">// 2.否则要往下走找到[l,r]完全包含子节点整个区间的情况</span><br>        lazyCreate(root);   <span class="hljs-comment">// 动态开点</span><br>        pushDown(root); <span class="hljs-comment">// 下传懒标记</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> root.left + (root.right - root.left) / <span class="hljs-number">2</span>; <span class="hljs-comment">// root区间中点</span><br>        <span class="hljs-comment">// 左子树范围[ll, mid] 右子树范围[mid+1,rr]</span><br>        <span class="hljs-keyword">if</span> (r &lt;= mid) &#123; <span class="hljs-comment">// [l,r]只占据到root左子树</span><br>            <span class="hljs-keyword">return</span> query(root.leftChild, l, r);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; mid) &#123;   <span class="hljs-comment">// [l,r]只占据到root右子树</span><br>            <span class="hljs-keyword">return</span> query(root.rightChild, l, r);<br>        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// [l,r]占据root左子树与右子树</span><br>            <span class="hljs-keyword">return</span> query(root.leftChild, l, mid) + query(root.rightChild, mid + <span class="hljs-number">1</span>, r);<br>        &#125;<br>        <span class="hljs-comment">// 不用上传结果了因为查询不改变节点的值</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    上传结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushUp</span><span class="hljs-params">(Node root)</span> &#123;<br>        root.val = root.leftChild.val + root.rightChild.val;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    下传懒标记:有懒标记-&gt;下传懒标记并更新子节点的值;没有-&gt;结束</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushDown</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-comment">// 当且仅当有懒标记才进行下传</span><br>        <span class="hljs-keyword">if</span> (root.lazy != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 懒标记的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> root.lazy;<br>            <span class="hljs-comment">// 懒标记下沉至左右子节点</span><br>            <span class="hljs-comment">// 这里懒标记累加还是覆盖可以根据具体问题进行分析</span><br>            <span class="hljs-comment">// 比如说是求区间的累加值就是+= 如果是只有两个状态那种可以直接进行覆盖(LC715.Range模块)</span><br>            root.leftChild.lazy += v;<br>            root.rightChild.lazy += v;<br>            <span class="hljs-comment">// 更新左右子节点的值</span><br>            root.leftChild.val += (root.leftChild.right - root.leftChild.left + <span class="hljs-number">1</span>) * v;<br>            root.rightChild.val += (root.rightChild.right - root.rightChild.left + <span class="hljs-number">1</span>) * v;<br>            <span class="hljs-comment">// root取消懒标记</span><br>            root.lazy = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建左右子树</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyCreate</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> root.left + (root.right - root.left) / <span class="hljs-number">2</span>; <span class="hljs-comment">// root区间中点</span><br>        <span class="hljs-comment">// 创建左右子树并构建连接</span><br>        <span class="hljs-keyword">if</span> (root.leftChild == <span class="hljs-literal">null</span>) root.leftChild = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(root.left, mid);<br>        <span class="hljs-keyword">if</span> (root.rightChild == <span class="hljs-literal">null</span>) root.leftChild = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(mid + <span class="hljs-number">1</span>, root.right);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>数组表示的线段树(含懒标记+动态开点)可以参考三叶：</strong></p><p><a href="https://leetcode.cn/problems/my-calendar-i/"><strong>729. 我的日程安排表 I</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.SegmentTree;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Fomalhaut</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/24</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 729. 我的日程安排表 I</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Q729</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyCalendar</span> <span class="hljs-variable">myCalendar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCalendar</span>();<br>        System.out.println(myCalendar.book(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));    <span class="hljs-comment">// true</span><br>        System.out.println(myCalendar.book(<span class="hljs-number">15</span>, <span class="hljs-number">25</span>));    <span class="hljs-comment">// false</span><br>        System.out.println(myCalendar.book(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>));    <span class="hljs-comment">// true</span><br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendar</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        本题是线段树的模板题之一,由于值域范围在[0,1e9]因此只能采用动态开点的方式,否则会出现MLE</span><br><span class="hljs-comment">        本题要动态地获当前区间是否完全被覆盖,可以将线段树节点值设为当前区间的节点数(叶子结点只有0与1的区间和)</span><br><span class="hljs-comment">        同时为了使查询的时间复杂度为严格的O(logN)要加入懒标记</span><br><span class="hljs-comment">        -&gt;查询[start,end)区间是否能book就相当于求[start,end-1]的区间和是否为0</span><br><span class="hljs-comment">        懒标记的线段树空间复杂度为O(MlogN),M为操作次数; 查询和更新一次时间复杂度为:O(logN)</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         节点类:</span><br><span class="hljs-comment">         本节点与之前的模板不同,该节点成员没有显式地包含节点u的区间左右端点[lc,rc]</span><br><span class="hljs-comment">         区间左右端点[lc,rc]可以通过update()与query()显式地传入再进行递归计算</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>            <span class="hljs-comment">// ls 与rs 分别代表当节点的左右子节点在tr中的下标 (相当于leftChild与rightChild)</span><br>            <span class="hljs-comment">// val 表示当前节点的区间和(只有0与1)</span><br>            <span class="hljs-comment">// add为懒标记</span><br>            <span class="hljs-type">int</span> ls, rs, add, val;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span>, M = <span class="hljs-number">120010</span>, cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">// N 区间范围; M 节点个数; cnt 节点索引</span><br>        Node[] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[M];    <span class="hljs-comment">// 数组表示的线段树</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendar</span><span class="hljs-params">()</span> &#123;<br>            tr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(); <span class="hljs-comment">// 根节点u从tr[0]开始</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        更新[l,r]区间的节点,更新值为val=1</span><br><span class="hljs-comment">        u 根节点索引;lc 与 rc 代表根节点u表示的值域范围</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-comment">// 节点u表示的范围[lc,rc]在[l,r]内部 -&gt; 直接更新节点值和懒标记</span><br>            <span class="hljs-keyword">if</span> (lc &gt;= l &amp;&amp; rc &lt;= r) &#123;<br>                tr[u].val = (rc - lc + <span class="hljs-number">1</span>) * val;<br>                tr[u].add = val;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            lazyCreate(u);  <span class="hljs-comment">// 动态开点</span><br>            pushDown(u, rc - lc + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 下传懒标记</span><br>            <span class="hljs-comment">// 递归更新左右子节点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lc + (rc - lc) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) update(tr[u].ls, lc, mid, l, r, val); <span class="hljs-comment">// [l,r]占据到左子树</span><br>            <span class="hljs-keyword">if</span> (r &gt; mid) update(tr[u].rs, mid + <span class="hljs-number">1</span>, rc, l, r, val);  <span class="hljs-comment">// [l,r]占据到右子树</span><br>            pushUp(u);  <span class="hljs-comment">// 回溯更新u的值</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        查询[l,r]区间的节点</span><br><span class="hljs-comment">        u 根节点索引;lc 与 rc 代表根节点u表示的值域范围</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>            <span class="hljs-keyword">if</span> (lc &gt;= l &amp;&amp; rc &lt;= r) <span class="hljs-keyword">return</span> tr[u].val;   <span class="hljs-comment">// u节点区间在[l,r]内</span><br>            <span class="hljs-comment">// 否则继续往下走</span><br>            lazyCreate(u);  <span class="hljs-comment">// 动态开点</span><br>            pushDown(u, rc - lc + <span class="hljs-number">1</span>); <span class="hljs-comment">// 下传懒标记</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lc + (rc - lc) / <span class="hljs-number">2</span>, res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) res = query(tr[u].ls, lc, mid, l, r); <span class="hljs-comment">// [l,r]占据到左子树</span><br>            <span class="hljs-keyword">if</span> (r &gt; mid) res += query(tr[u].rs, mid + <span class="hljs-number">1</span>, rc, l, r);  <span class="hljs-comment">// [l,r]占据到右子树</span><br>            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回左右区间总和</span><br>            <span class="hljs-comment">// 查询不更新端点的值因此不用回溯</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        向上更新u的值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            tr[u].val = tr[tr[u].ls].val + tr[tr[u].rs].val;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        下传懒标记</span><br><span class="hljs-comment">        其中 len 为节点表示的区间长度 用于简化计算区间长度</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushDown</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> len)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> tr[u].add;<br>            <span class="hljs-keyword">if</span> (v != <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 逐一懒标记不为0才下传</span><br>                <span class="hljs-comment">// 1.下传懒标记</span><br>                tr[tr[u].ls].add = v;<br>                tr[tr[u].rs].add = v;<br>                <span class="hljs-comment">// 2.更新子节点的值(不判断懒标记就要+=避免0覆盖)</span><br>                tr[tr[u].ls].val = (len - len / <span class="hljs-number">2</span>) * v; <span class="hljs-comment">// 左(大)</span><br>                tr[tr[u].rs].val = (len / <span class="hljs-number">2</span>) * v;   <span class="hljs-comment">// 右(小)</span><br>                <span class="hljs-comment">// 3.懒标记下传完置0</span><br>                tr[u].add = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        动态开点:动按需态创建左右子节点并构建连接</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            <span class="hljs-keyword">if</span> (tr[u].ls == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 当且仅当左子节点没有时才进行开点(tr[u].ls为0表示还没开左子节点)</span><br>                tr[u].ls = cnt++;   <span class="hljs-comment">// 构建与tr[u]的连接,索引依次取</span><br>                tr[tr[u].ls] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();  <span class="hljs-comment">// 开点</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (tr[u].rs == <span class="hljs-number">0</span>) &#123;<br>                tr[u].rs = cnt++;<br>                tr[tr[u].rs] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>            <span class="hljs-comment">// 区间[start,end-1]已经有东西填充过了-&gt;不能book</span><br>            <span class="hljs-keyword">if</span> (query(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 否则更新并返回true</span><br>            update(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-ac_oier-okkc/"><strong>731. 我的日程安排表 II</strong></a><strong>(注意节点维护的是最大值)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.SegmentTree;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Fomalhaut</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/24</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 731. 我的日程安排表 II</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Q731</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyCalendarTwo</span> <span class="hljs-variable">MyCalendar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCalendarTwo</span>();<br>        System.out.println(MyCalendar.book(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));    <span class="hljs-comment">// true</span><br>        System.out.println(MyCalendar.book(<span class="hljs-number">50</span>, <span class="hljs-number">60</span>));    <span class="hljs-comment">// true</span><br>        System.out.println(MyCalendar.book(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>));    <span class="hljs-comment">// true</span><br>        System.out.println(MyCalendar.book(<span class="hljs-number">5</span>, <span class="hljs-number">15</span>));     <span class="hljs-comment">// false</span><br>        System.out.println(MyCalendar.book(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>));     <span class="hljs-comment">// true</span><br>        System.out.println(MyCalendar.book(<span class="hljs-number">25</span>, <span class="hljs-number">55</span>));    <span class="hljs-comment">// true</span><br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendarTwo</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这题也可以用线段树进行求解:start与end的范围为[0,1e9]</span><br><span class="hljs-comment">        不过相比于Q729 我的日程安排表I 这里要维护的val为区间的最大值max</span><br><span class="hljs-comment">        当区间的最大值&gt;=2就说明已经有两个重叠的预订,第3个预订就不能book了</span><br><span class="hljs-comment">        查询和更新一次时间复杂度为:O(logN) 空间复杂度为O(MlogN),M为操作次数</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        节点类</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>            <span class="hljs-type">int</span> ls, rs, add, max;   <span class="hljs-comment">// ls, rs 为左右子节点在tr中索引(触手); add 懒标记; max 维护区间最大值</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span>, M = <span class="hljs-number">120010</span>, cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">// N 区间范围; M 节点个数; cnt 节点在tr中的索引</span><br>        Node[] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[M];<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendarTwo</span><span class="hljs-params">()</span> &#123;<br>            tr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(); <span class="hljs-comment">// 创建根节点</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        更新区间[l,r] 值为val</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-comment">// [l,r]在u表示的区间内</span><br>            <span class="hljs-keyword">if</span> (lc &gt;= l &amp;&amp; rc &lt;= r) &#123;<br>                tr[u].add += val;   <span class="hljs-comment">// 懒标记要累计(例如覆盖了2次)</span><br>                <span class="hljs-comment">// 最大值是max(curVal,curVal+val)=curVal+val -&gt; max += val;</span><br>                tr[u].max += val;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 结束</span><br>            &#125;<br>            <span class="hljs-comment">// [l,r]不在u内</span><br>            lazyCreate(u);  <span class="hljs-comment">// 动态开点</span><br>            pushDown(u);    <span class="hljs-comment">// 下传懒标记</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lc + (rc - lc) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) update(tr[u].ls, lc, mid, l, r, val); <span class="hljs-comment">// 占据到左子树</span><br>            <span class="hljs-keyword">if</span> (r &gt; mid) update(tr[u].rs, mid + <span class="hljs-number">1</span>, rc, l, r, val);  <span class="hljs-comment">// 占据到右子树</span><br>            pushUp(u);  <span class="hljs-comment">// 回溯</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">       查询区间[l,r]的最大值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>            <span class="hljs-keyword">if</span> (lc &gt;= l &amp;&amp; rc &lt;= r) <span class="hljs-keyword">return</span> tr[u].max;<br>            lazyCreate(u);  <span class="hljs-comment">// 冬天开点</span><br>            pushDown(u);    <span class="hljs-comment">// 下传懒标记</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lc + (rc - lc) / <span class="hljs-number">2</span>, res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) res = query(tr[u].ls, lc, mid, l, r);<br>            <span class="hljs-keyword">if</span> (r &gt; mid) res = Math.max(res, query(tr[u].rs, mid + <span class="hljs-number">1</span>, rc, l, r));   <span class="hljs-comment">// 记得取左右子节点的最大值</span><br>            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回最大值</span><br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        按需动态开点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            <span class="hljs-keyword">if</span> (tr[u].ls == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 左子节点不存在 -&gt; 创建并构建连接</span><br>                tr[u].ls = cnt++;<br>                tr[tr[u].ls] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tr[u].rs == <span class="hljs-number">0</span>) &#123;<br>                tr[u].rs = cnt++;<br>                tr[tr[u].rs] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        下传懒标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushDown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> tr[u].add;  <span class="hljs-comment">// 节点u下传下来的懒标记</span><br>            <span class="hljs-keyword">if</span> (v != <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 当且仅当懒标记不为0才进行下传</span><br>                <span class="hljs-comment">// 下传懒标记至子节点(累计)</span><br>                tr[tr[u].ls].add += v;<br>                tr[tr[u].rs].add += v;<br>                <span class="hljs-comment">// 更新左右子节点的值(累计)</span><br>                tr[tr[u].ls].max += v;<br>                tr[tr[u].rs].max += v;<br>                tr[u].add = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 下传懒标记完成撤销u的懒标记</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        回溯更新u的最大值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            tr[u].max = Math.max(tr[tr[u].ls].max, tr[tr[u].rs].max);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>            <span class="hljs-comment">// 最大值&gt;=2说明区间[start,end-1]存在某个点覆盖了2次</span><br>            <span class="hljs-keyword">if</span> (query(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            update(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>做完这两题估计对线段树有了充分了解了！</p><h3 id="3-差分数组-「区间修改-单点查询」：">3.差分数组-&gt;「区间修改 &amp; 单点查询」：</h3><p>差分区间求和:将每个区间覆盖信息转化为<strong>变化量</strong>记录,最后<strong>从头开始统计变化量</strong>就可以将总的变化量求出来</p><p>比喻成公交车:上车就表示该时刻t1-&gt;新区间加入乘客+1；下车就表示区间结束-&gt;下一个时刻(t2+1)乘客-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] corpFlightBookings(<span class="hljs-type">int</span>[][] bookings, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">//  注意航班编号为1-n</span><br>        <span class="hljs-comment">// 变化量计数器:索引[0,n-1]</span><br>        <span class="hljs-type">int</span>[] counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 遍历每个区间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] booking : bookings) &#123;<br>            <span class="hljs-comment">// 因为航班编号为1-n,因此左偏移一位才是counter索引</span><br>            counter[booking[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>] += booking[<span class="hljs-number">2</span>];<br>            <span class="hljs-comment">// 这里原本有+1又向左偏移一位就是原本的,要判断区间是否合法</span><br>            <span class="hljs-keyword">if</span>(booking[<span class="hljs-number">1</span>] &lt; n) counter[booking[<span class="hljs-number">1</span>]] -= booking[<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-comment">// 该站人数=上一站人数+该站变化量</span><br>        <span class="hljs-comment">// 注意最初的一站就是0+counter[0]=counter[0]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            counter[i] += counter[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 差分 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集专题</title>
      <link href="/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%93%E9%A2%98.html"/>
      <url>/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p>并查集是一种树型数据结构(多叉树)，可以高效地实现查找和合并功能，常用于求<strong>连通</strong>问题</p><p>1.每个数据可以看作一个节点</p><p>2.每一组数据都是一颗树</p><p>3.一个组中的数据对应的树和另外一个组中数据对应的树之间没有任何关系</p><p>4.初始化的时候把索引当作每个组的标识符</p><p><strong>并查集主要有三个功能：</strong></p><p>1.<strong>寻找根节点</strong>，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</p><p>2.<strong>将两个节点接入到同一个集合</strong>，函数：join(int u, int v)，将两个节点连在同一个根节点上</p><p>3.<strong>判断两个节点是否在同一个集合</strong>，函数：same(int u, int v)，就是判断两个节点是不是同一个根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1005</span>; <span class="hljs-comment">// 节点数量3 到 1000</span><br><span class="hljs-type">int</span>[] father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// father[i]为节点i的父亲</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 并查集寻根</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>    <span class="hljs-comment">// return u == father[u] ? u : father[u] = find(father[u]);</span><br>    <span class="hljs-keyword">if</span>(father[u]!=u) father[u]=find(father[u]); <span class="hljs-comment">// 递归返回的同时压缩路径</span><br>    <span class="hljs-keyword">return</span> father[u];<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集(合并:其中u为根节点)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> &#123;<br>    u = find(u);<br>    v = find(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    father[v] = u;<br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v 是否位于同一个连通域(同根)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> &#123;<br>    u = find(u);<br>    v = find(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 每个连通域根节点都是独一无二的，因此可以通过某个节点寻根+HashMap统计出每个连通域的节点数量以及连通域个数等，而不用多一个字段值sum，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据图的信息构建连接</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>    join(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// 由于每个连通块的根都是唯一的,因此我们可以利用此来统计连通块内的元素个数</span><br>HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> find(i); <span class="hljs-comment">// 该连通域对应的根节点</span><br>    map.put(root, map.getOrDefault(root, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map.size()</code>就是连通域数量；<code>map.get(find(x))</code>就是节点x所在连通域节点数量</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记忆化搜索专题</title>
      <link href="/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98.html"/>
      <url>/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-300/"><strong>第300场周赛</strong></a></p><p>这次周赛的第3与第4题均可以用记忆化DFS进行求解，第一次尝试这种强大的方法，是动态规划的底层逻辑演算！记忆化DFS的首条件是出现子问题并且子问题数量有限</p><p>通过记忆化搜索可以将时间复杂度从2^N降低至O(N)</p><p><a href="https://leetcode.cn/problems/number-of-people-aware-of-a-secret/">6109. 知道秘密的人数</a></p><p>例如这一题的 dfs(i) 为第 i 天发现的秘密的人(包含自己在内)一共可以使得后面多少人知道秘密</p><p>我们可以怎样求dfs(i)？他可以由哪几个子问题的结果运算得到？</p><p>某个人在第 i 天知道秘密，则对应的传播阶段为 [min(i+delay,n),min(i+forget-1,n)] 记为 [a,b]</p><p>此时知道秘密的人数有dfs(i)=1+∑dfs(a,b) 其中1为自己本身</p><p>只需要处理好base case和memo，同时注意 i 本身也会忘记 就可以轻松写出来</p><p>这种一路dfs到底的写法，利用dfs递归返回的结果进行中间运算的方法称为非回溯型的写法</p><p>跟回溯写法的区别就是，回溯类型写法需要找到并保存所有的path</p><p>在这里我们只需要知道dfs(i)的计算值即可，因此这里dfs(i)带上返回参数int类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n, delay, forget;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span>[] memo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peopleAwareOfSecret</span><span class="hljs-params">(<span class="hljs-type">int</span> _n, <span class="hljs-type">int</span> _delay, <span class="hljs-type">int</span> _forget)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Java 记忆化搜索:</span><br><span class="hljs-comment">        我们记dfs(i)为第i天发现的秘密的人包含自己在内一共可以使得后面多少人知道秘密</span><br><span class="hljs-comment">        i从i+delay天起,到i+forget-1天都是可以将秘密散播出去的</span><br><span class="hljs-comment">        也就是[min(i+delay,n),min(i+forget-1,n)]=[a,b]这个时间段是i的传播阶段</span><br><span class="hljs-comment">        此时知道秘密的人数有1+∑dfs(a,b)</span><br><span class="hljs-comment">        同时应该注意知道了秘密的人会忘记秘密,因此也会有一个期限</span><br><span class="hljs-comment">        这里由于子问题的出现可以使用记忆化减少搜索次数</span><br><span class="hljs-comment">         */</span><br>        n = _n;<br>        delay = _delay;<br>        forget = _forget;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-comment">// 在第n天之后才能传播,说明只有自己知道</span><br>        <span class="hljs-keyword">if</span> (i + delay &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 已经搜索过直接返回</span><br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-comment">// i传播的范围为[min(i+delay,n),min(i+forget-1,n)]=[a,b]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i + delay, b = Math.min(i + forget - <span class="hljs-number">1</span>, n);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> i + forget &lt;= n ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;    <span class="hljs-comment">// 自身到[i+forget]就忘记了,在n天内忘记了取0,反之取1</span><br>        <span class="hljs-comment">// 合法的传播范围为[a,b]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> a; j &lt;= b; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(j);<br>            memo[j] = t;    <span class="hljs-comment">// 标记</span><br>            res = (res + t) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/">6110. 网格图中递增路径的数目</a></p><p>这道题一样时可以利用子问题的搜索结果减少计算量的题目</p><p>dfs(i,j)主逻辑:grid[i][j]出发的递增路径数=本身自成1条路径+上下左右出发严格递增路径数之和</p><p>另外用一个memo[i][j]保存从grid[i][j]出发的递增路径数</p><p>另外有一些细节：vis的标记方法与撤回、memo的标记方法（怎样才做到不重复标记）、取模技巧（可能溢出的变量要用long类型）等等…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo, grid;<br>    <span class="hljs-type">boolean</span>[][] vis;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] _grid)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        dfs记忆化搜索:</span><br><span class="hljs-comment">        从每个格子出发搜索递增的路径数有多少</span><br><span class="hljs-comment">        有上下左右4个方向,合法的方向是比之前格子严格大的</span><br><span class="hljs-comment">        另外用一个memo[i][j]保存从grid[i][j]出发的递增路径数</span><br><span class="hljs-comment">        dfs(i,j)主逻辑:grid[i][j]出发的递增路径数=本身自成1条路径+上下左右出发严格递增路径数之和</span><br><span class="hljs-comment">         */</span><br>        grid = _grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];    <span class="hljs-comment">// 保存当前路径访问过的格子:回溯形式标记,递归出栈时候会恢复原状</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 统计每一个出发点的递增路径</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                vis[i][j] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 进入dfs前标记搜索</span><br>                res = (res + dfs(i, j)) % MOD;<br>                vis[i][j] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 撤回</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// 已经搜索过了,直接返回其数值</span><br>        <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i][j];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;   <span class="hljs-comment">// 本身自成一条严格递增路径</span><br>        <span class="hljs-comment">// 一共有4个搜索方向</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newI</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], newJ = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 越界||已经搜索过||大小不符合要求</span><br>            <span class="hljs-keyword">if</span> (newI &lt; <span class="hljs-number">0</span> || newI &gt;= m || newJ &lt; <span class="hljs-number">0</span> || newJ &gt;= n || vis[newI][newJ] || grid[newI][newJ] &lt;= grid[i][j])<br>                <span class="hljs-keyword">continue</span>;<br>            vis[newI][newJ] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记搜索</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(newI, newJ);    <span class="hljs-comment">// 下一点出发点路径数</span><br>            vis[newI][newJ] = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 记得撤回访问标记,因为仅需要标记单一路径上的;从另外一点出发可以经过同一条路径</span><br>            res = (res + t) % MOD;  <span class="hljs-comment">// 累加结果</span><br>        &#125;<br>        memo[i][j] = (<span class="hljs-type">int</span>) res; <span class="hljs-comment">// 标记grid[i][j]出发的路径数</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 记忆化DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间DP专题总结</title>
      <link href="/%E5%8C%BA%E9%97%B4DP%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
      <url>/%E5%8C%BA%E9%97%B4DP%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>区间DP是指以区间左右边界 f[i][j] 作为动态规划变量的问题</p><p>一般求解步骤：</p><p>1.状态定义：f[i][j] 为<strong>求解分区间 [i,j] 重复子问题的开销</strong>，其中 i&lt;=j</p><p>2.状态转移：求f[i][j]通常要考虑<strong>将 [i, j] 区间分为两个重复子问题</strong></p><p>这个根据具体的问题而定，有的可能要根据s[i]与s[j]是否相等做出不同的转移，如 <a href="https://leetcode.cn/problems/strange-printer/">664. 奇怪的打印机</a></p><p>有的可能是选择直接枚举分割点k，然后建立 [i, j] 区间与 左右子区间的转移，如 <a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></p><p>有的还可能不是分割区间，而是利用缩小区间 [i+1,j] 的子问题与 [i, j] 区间建立连接，如 <a href="https://leetcode-cn.com/problems/stone-game/">877. 石子游戏</a></p><p>3.初始化：通常来说要初始化<strong>长度为1的边界状态 f[i][i] 的值</strong>，为接下来的遍历做好初值准备</p><p>4.遍历顺序：这里有两种遍历的方法，推荐<strong>以遍历长度len</strong>的方法</p><p><strong>4.1 长度len为基础进行遍历</strong></p><p>1.遍历长度len(正序2~n)；</p><p>2.遍历左边界i(正序0~i+len-1==n-1)；</p><p>3.遍历分割点k(正反序无所谓i~j-1)</p><p>​      <strong>4.2 i与j为基础进行遍历</strong></p><p>1.枚举左端点i(倒序n-2~0)</p><p>2.枚举右端点j(正序i+1~n-1)</p><p>3.枚举分割点k(正反序无所谓i~j-1)</p><p>此时以k分割后的左右子区间分别为：[i,k] 与 [k+1,j]</p><p>示意图如下：可知分割区间依赖于正下方和正左方的状态有效值-&gt;<strong>遍历长度是以“滑梯”的方式下去的；遍历i与j是从底下上来的</strong></p><p><img src="../images/p9.jpg" alt="p9"></p><p>5.返回形式：一般来说返回 <strong>f[0][n-1]</strong> 就是关于整个区间对应的子问题答案</p><p>复杂度分析：一般地，时间复杂度:O(N^3)；空间复杂度:O(N^2)</p><p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/"><strong>375. 猜数字大小 II</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        解法2：区间DP</span><br><span class="hljs-comment">        1.状态定义:f[i][j]为确保猜中区间[i,j]至少需要的金额，其中 j&gt;=i &amp;&amp; i,j∈[1,n]</span><br><span class="hljs-comment">        2.状态转移:要想求解f[i][j]就要考虑f[i][k-1]与f[k+1][j]</span><br><span class="hljs-comment">            其中k为区间的分割点（某次猜的数字为k），遍历k∈[i,j]，求得该次稳赢的开销为 k+max(f[i][k-1],f[k+1][j])</span><br><span class="hljs-comment">            遍历k过程中维护[i,j]区间分割成两个区间后的最小值min，那么min就是f[i][j]的值</span><br><span class="hljs-comment">        3.初始化:f[i][j]=0 其中i&gt;=j</span><br><span class="hljs-comment">        4.遍历顺序:求f[i][j]要用到f[i][k-1]与f[k+1][j] 那么j正序 i倒序 k无所谓</span><br><span class="hljs-comment">        5.返回形式:返回f[1][n]就是答案</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 遍历左边界i∈[n,1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            <span class="hljs-comment">// 遍历右边界j∈[i+1,n] 注意j=i为0 强行转移会发生错误</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> INF;<br>                <span class="hljs-comment">// 遍历分界线k∈[i,j]</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> k + Math.max(f[i][k - <span class="hljs-number">1</span>], f[k + <span class="hljs-number">1</span>][j]);   <span class="hljs-comment">// 本次猜k的稳赢的开销</span><br>                    min = Math.min(min, cur);   <span class="hljs-comment">// 这么多种选择的最小开销</span><br>                &#125;<br>                f[i][j] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">1</span>][n];     <span class="hljs-comment">// 选择[1,n]中稳赢的最小开销</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/strange-printer/"><strong>664. 奇怪的打印机</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strangePrinter</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        方法2：区间DP</span><br><span class="hljs-comment">        1.状态定义:f[i][j]为打印s[i,j]所需要的最少打印次数（i&lt;=j）</span><br><span class="hljs-comment">        2.状态转移:求f[i][j]就要考虑s[i]与s[j]</span><br><span class="hljs-comment">            2.1 当s[i]==s[j]时 s[i]与s[j]其中一个可以顺路打印 f[i][j]=f[i][j-1]</span><br><span class="hljs-comment">            2.1 当s[i]=!s[j]时 枚举分割点，分割点两边的次数加起来取最小值就是答案(只取最优的打印次数转移)</span><br><span class="hljs-comment">                f[i][j]=min(f[i][k]+f[k+1][j]) 其中k∈[i,j-1]</span><br><span class="hljs-comment">        3.初始化:初始化f[i][i]=1 单个字符最少打印1次</span><br><span class="hljs-comment">        4.遍历顺序:Loop1-&gt;遍历长度len(正序)  Loop2-&gt;遍历左边界i(正序)  Loop3-&gt;遍历分割点k(正序)</span><br><span class="hljs-comment">            另一个遍历角度:枚举左端点i(倒序n-2~0) 枚举右端点j(正序i~n-1) 枚举分割点k(没所谓i~j-1)</span><br><span class="hljs-comment">        5.返回形式:返回f[0][n-1]就是打印s[0,n-1]所需要的最小打印次数</span><br><span class="hljs-comment">        时间复杂度:O(N^3) 空间复杂度:O(N^2)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), INF = <span class="hljs-number">101</span>;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-comment">// 打印1个字符只需要1次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            f[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 枚举长度len∈[2,len]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; len &lt;= n; len++) &#123;<br>            <span class="hljs-comment">// 枚举左端点i∈[0,n-len]</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; i++) &#123;<br>                <span class="hljs-comment">// j为右端点</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + len - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// s[i]==s[j] 顺路打印</span><br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                    f[i][j] = f[i][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> INF;  <span class="hljs-comment">// 最多的打印次数</span><br>                    <span class="hljs-comment">// 枚举分割点k∈[i,j-1]</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt; j; k++) &#123;<br>                        <span class="hljs-comment">// 维护最小的打印次数</span><br>                        min = Math.min(min, f[i][k] + f[k + <span class="hljs-number">1</span>][j]);<br>                    &#125;<br>                    f[i][j] = min;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>记忆化DFS解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] memo;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">101</span>;<br>    <span class="hljs-type">char</span>[] chs;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strangePrinter</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        方法1：记忆化DFS:</span><br><span class="hljs-comment">        关注子问题，每当打印一段涉及到的变量为的当前打印区间的左右边界s[i,j]</span><br><span class="hljs-comment">        因此定义dfs(i,j)为打印s[i,j]需要的最少打印次数</span><br><span class="hljs-comment">        此时情况分为2种：</span><br><span class="hljs-comment">        1.当s[i]==s[j]时，打印s[i]时可以同时把s[j]也打印了，因此总的次数为dfs(i,j-1)</span><br><span class="hljs-comment">        2.当s[i]!=s[j]时，打印s[i]时不能同时把s[j]也打印</span><br><span class="hljs-comment">            假设中间的字母都不相同的情况下，总的次数需要dfs(i,j-1)+1，即每个字母都要独立打印</span><br><span class="hljs-comment">            但是s[i...k...j]中间的s[k]可能与s[i]或者s[j]相等，此时的打印次数可以减少，因为可以顺带打印</span><br><span class="hljs-comment">            那么就要枚举s[i,j]之间的分割点s[k]，其中k∈[i,j-1]，分割后的区间为s[i,k]与s[k+1,j]</span><br><span class="hljs-comment">            最少的打印次数为多少？答案为min(dfs(i,k)+dfs(k+1,j)) 中间可以顺带打印的都经过了最优的状态转移</span><br><span class="hljs-comment">        最后返回dfs(0,n-1)就是答案</span><br><span class="hljs-comment">         */</span><br>        chs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> chs.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// dfs(i,j):打印s[i,j]需要的最少打印次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// memo中存在该状态直接返回</span><br>        <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i][j];<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// s[i]==s[j]</span><br>        <span class="hljs-keyword">if</span> (chs[i] == chs[j]) <span class="hljs-keyword">return</span> dfs(i, j - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt; j; k++) &#123;<br>            min = Math.min(min, dfs(i, k) + dfs(k + <span class="hljs-number">1</span>, j)); <span class="hljs-comment">// 取最小分割位置赋值到dfs(i,j)</span><br>        &#125;<br>        memo[i][j] = min;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实能用动态规划解决的问题都可以用记忆化DFS解决</p><p>记忆化DFS的优点就是不用考虑具体的状态遍历顺序是怎样的，只要能够判断出memo里面的状态被有效值覆盖过就可以直接拿来用，因此可以将 memo[i][j] 的值初始化为一个不可能到达的值INF</p><p>模板中一般包含一下几个关键点：</p><p>1.每次递归返回之前记录该次最优值进入memo memo[i][j] = min;</p><p>2.若dfs(i,j)中的memo[i][j]的有效值已经出现过可以直接取 if (memo[i][j] != 0) return memo[i][j];</p><p>3.base case 一般来说是 if (i == j) return ?;</p><p>4.遍历与dfs(i,j)有关的状态（结果），选择最优的（经过计算）得到的结果作为dfs(i,j)的结果 视具体问题而定</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间DP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位DP总结</title>
      <link href="/%E6%95%B0%E4%BD%8DDP%E6%80%BB%E7%BB%93.html"/>
      <url>/%E6%95%B0%E4%BD%8DDP%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>位DP是一种比较抽象和难理解的DP题型，什么时候会用到数位DP去解题？</p><p>一般来说，当遇到求 [a,b] 内满足一定条件的数字有多少个时，大概率会用到数位DP</p><p>设 f[i] 为 [0,i] 满足条件的数字个数，那么[a, b] 内的符合要求数目就是 f[b]-f[a]</p><p>三叶的数位DP方面总结得比较系统，题解也是比较模板化的，<strong>建议按照模板来</strong>，大致梳理一下模板和思路如下：</p><p>将 [0,n] 的数字分为3部分：</p><p>1.<strong>res1</strong> <strong><em>位数小于n</em><strong>的部分 这部分一般可以通过</strong>乘法原理</strong>求解</p><p>2.<strong>res2</strong> <strong><em>位数等于n且最高位小于n部分</em></strong> 这部分也可以用乘法原理进行求解，<strong>枚举最高位可用的情形然后利用乘法原理计算</strong></p><p>3.<strong>res3</strong> <strong><em>位数等于n且最高位等于n部分</em></strong> 这部分是最难的，因为每一位的取值严格被限制了，需要用到DP的思想进行求解</p><p>（注意这个res3不一定是n的最高位，是遍历过程中作为状态值动态变化的）</p><p>res2与res3一般放在一起求解，套路如下：</p><p>从<strong>高位向低位</strong>枚举，假设当前位数字为cur，其中res2部分可以通过乘法原理计算得到</p><p>res3部分需要由 <strong>当前位的后面位方案</strong>数 决定，这里就有了子问题的复现了，原问题与子问题的维度差异就是子问题比原问题少了原来的最高位</p><p>以 LC 1012为例</p><p>res2 = [0,cur-1]能用的数字数 * 后面剩余位数的排列数</p><p><code>res3相当于固定了当前位为最大值cur，再看后面位总的方案数，通过for循环一直遍历至最后一位(或者是出现重复的一位)</code></p><p>还有一个细节就是别漏了最大数本身也符合要求这种情形</p><p>排列数的情形有限，我们可以预处理出来所有排列数来加快计算速度</p><p>最后再累加上res1的方案数就是答案</p><p><a href="https://leetcode.cn/problems/numbers-with-repeated-digits/"><strong>1012. 至少有 1 位重复的数字</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 预处理排列数 f[i][j]=i*(i+1)*...*(j-1)*j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; <span class="hljs-number">11</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++) &#123;<br>                    cur *= k;<br>                &#125;<br>                f[i][j] = cur;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDupDigitsAtMostN</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        数位DP(较难):</span><br><span class="hljs-comment">        本题可以转化为求[1,n]全部数字不相同的数字个数，是典型的数位DP问题</span><br><span class="hljs-comment">        数位DP问题求解的总体思路就是求[0,n]中满足某些条件的数字个数</span><br><span class="hljs-comment">        通常套路就是将[0,n]的数字分为3部分：</span><br><span class="hljs-comment">        1.res1 位数小于n的部分 这部分与 LC357 解法一致，利用乘法原理求解</span><br><span class="hljs-comment">        2.res2 位数等于n的部分且最高位小于n 这部分也可以用乘法原理进行求解，枚举最高位直接计算就可以</span><br><span class="hljs-comment">        3.res3 位数等于n的部分且最高位等于n 这部分是最难的，因为每一位的取值严格被限制了，需要用到DP的思想进行求解</span><br><span class="hljs-comment">        res2与res3一般放在一起求解，套路如下：</span><br><span class="hljs-comment">        从高位向低位枚举，假设当前位为cur，其中res2部分可以通过乘法原理计算得到</span><br><span class="hljs-comment">        res3部分需要由  当前位的后面位方案数  决定</span><br><span class="hljs-comment">        具体的，res2=[0,cur-1]能用的数字数*后面剩余位数的排列数</span><br><span class="hljs-comment">                res3相当于固定了当前位为最大值cur，再看后面位的总的方案数，通过for循环一直遍历至最后一位(或者是出现重复的一位)</span><br><span class="hljs-comment">                排列数的情形有限，我们可以预处理出来加快计算速度</span><br><span class="hljs-comment">        时间复杂度:O(logN)  空间复杂度:O(C)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> n - dp(n) + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 注意排除掉0的情况</span><br>    &#125;<br><br>    <span class="hljs-comment">// dp[x]返回[0,x]中每一位都不同的数字数目</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 一位数直接返回x+1(因为包含0)</span><br>        <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 将x每一位提出来</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            list.add(x % <span class="hljs-number">10</span>);<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bitCnt</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 1.计算res1+res2部分</span><br>        <span class="hljs-comment">// 其中i为数字x的位索引，i越大表示位数越高(越左)</span><br>        <span class="hljs-comment">// p记录当前循环到的位置已经遍历了多少位</span><br>        <span class="hljs-comment">// used标记当前遍历过程中已经用了的哪些数字，到时候根据used排除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bitCnt - <span class="hljs-number">1</span>, used = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, p++) &#123;<br>            <span class="hljs-comment">// 首先计算当前位cur能用的数字个数cnt</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> list.get(i), cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 枚举[cur-1,0]，再排除掉前面已经用过的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> cur - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-comment">// 最高位可以用[cur-1,1]</span><br>                <span class="hljs-keyword">if</span> (i == bitCnt - <span class="hljs-number">1</span>) &#123;<br>                    cnt = cur - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 低位可以用[cur-1,0]没用过的任意数</span><br>                <span class="hljs-keyword">if</span> (((used &gt;&gt; j) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) cnt++;<br>            &#125;<br>            <span class="hljs-comment">// 计算res2部分</span><br>            <span class="hljs-comment">// 合法值 a&gt;=b 其中a为cur后面首位选择数，b为终点(最后一位)的选择数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> - p, b = a - (bitCnt - p) + <span class="hljs-number">1</span>;<br>            res += cnt * (i &gt; <span class="hljs-number">0</span> ? f[b][a] : <span class="hljs-number">1</span>);    <span class="hljs-comment">// 特例为最后一位的时候可以选cnt个</span><br>            <span class="hljs-comment">// 已经遇到相同数字，统计完cnt次以后([0,cur-1]的情况)就可以退出</span><br>            <span class="hljs-keyword">if</span> (((used &gt;&gt; cur) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) res++;  <span class="hljs-comment">// 当x本身就是合法案例，最后一位加完cnt之后还要再+1</span><br>            used |= (<span class="hljs-number">1</span> &lt;&lt; cur);  <span class="hljs-comment">// 标记使用了cur</span><br>        &#125;<br>        <span class="hljs-comment">// 2.计算res3部分(位数小于x的部分)</span><br>        res += <span class="hljs-number">10</span>;  <span class="hljs-comment">// 先统计一位数的情况</span><br>        <span class="hljs-comment">// 统计后面的[2,bitCnt-1]位:9*9  9*9*8  9*9*8*7 ...</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; bitCnt; i++) &#123;<br>            res += <span class="hljs-number">9</span> * f[<span class="hljs-number">11</span> - i][<span class="hljs-number">9</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数位DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多源BFS总结</title>
      <link href="/%E5%A4%9A%E6%BA%90BFS%E6%80%BB%E7%BB%93.html"/>
      <url>/%E5%A4%9A%E6%BA%90BFS%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-1020-飞地的数量">1.<a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a></h3><p>BFS标记已经搜索过的格子避免重复搜索，一定一定要在入队时候就标记搜索</p><p><strong>如果在出队时才标记搜索，那么下一层的节点可能会把上一层的重复入队，因为上一层前面的节点出队了，后面的还没出队因此还视为未被搜索，有重复入队的风险！</strong></p><p><strong>1.常规单源BFS解法：5ms</strong> <strong>48.8 MB</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] canReach;  <span class="hljs-comment">// canReach记录grid[i][j]是否能到达边界</span><br>    <span class="hljs-type">int</span>[][] grid;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] _grid)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        多源BFS:</span><br><span class="hljs-comment">        有一个技巧，要越过边界一定要经过边界，那么我们要求中间有哪些不能到达边界的，反过来就是要求哪些能到达边界的</span><br><span class="hljs-comment">        再反过来只需要从边界开始DFS看看能到达哪些陆地即可，再用总的陆地数减去能到达边界的陆地数就是不能到达的陆地数</span><br><span class="hljs-comment">        遍历格子的方式也可以是BFS</span><br><span class="hljs-comment">         */</span><br>        grid = _grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        canReach = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-comment">// 搜索4条边界的陆地</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) bfs(i, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (grid[i][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) bfs(i, n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) bfs(<span class="hljs-number">0</span>, j);<br>            <span class="hljs-keyword">if</span> (grid[m - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) bfs(m - <span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-comment">// 统计不能到达边界的数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !canReach[i][j]) res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// dfs(i,j)搜索与之连接的陆地并标记到canReach</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// grid[i][j]可以到达边界说明与之连通的已经搜索过了，结束</span><br>        <span class="hljs-keyword">if</span> (canReach[i][j]) <span class="hljs-keyword">return</span>;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        canReach[i][j] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 统一入队标记搜索(速度快很多避免重复搜索)</span><br>        que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span>[] poll = que.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], y = poll[<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 搜索4个方向</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dir[<span class="hljs-number">0</span>], newY = y + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 位于区域内并且是陆地就可以到达，且不能搜回头路</span><br>                    <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt;= m - <span class="hljs-number">1</span> &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt;= n - <span class="hljs-number">1</span> &amp;&amp; grid[newX][newY] == <span class="hljs-number">1</span> &amp;&amp; !canReach[newX][newY]) &#123;<br>                        canReach[newX][newY] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 统一入队标记搜索</span><br>                        que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newX, newY&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.多源BFS写法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] canReach;  <span class="hljs-comment">// canReach记录grid[i][j]是否能到达边界</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        多源BFS:</span><br><span class="hljs-comment">        有一个技巧，要越过边界一定要经过边界，那么我们要求中间有哪些不能到达边界的，反过来就是要求哪些能到达边界的</span><br><span class="hljs-comment">        再反过来只需要从边界开始BFS看看能到达哪些陆地即可，再用总的陆地数减去能到达边界的陆地数就是不能到达的陆地数</span><br><span class="hljs-comment">        这是多个源点的BFS，我们可以把多个节点同时入队，相当于开始就进行第二层的BFS</span><br><span class="hljs-comment">        时间复杂度:O(N^2)  空间复杂度:O(N)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 搜索4条边界的陆地</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                grid[i][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 访问过与边缘连通的陆地标记为2</span><br>                que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, <span class="hljs-number">0</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (grid[i][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                grid[i][n - <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>                que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, n - <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                grid[<span class="hljs-number">0</span>][j] = <span class="hljs-number">2</span>;<br>                que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, j&#125;);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (grid[m - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                grid[m - <span class="hljs-number">1</span>][j] = <span class="hljs-number">2</span>;<br>                que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;m - <span class="hljs-number">1</span>, j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span>[] poll = que.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], y = poll[<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 搜索4个方向</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dir[<span class="hljs-number">0</span>], newY = y + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 位于区域内并且是陆地就可以到达，且不能搜回头路</span><br>                    <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt;= m - <span class="hljs-number">1</span> &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt;= n - <span class="hljs-number">1</span> &amp;&amp; grid[newX][newY] == <span class="hljs-number">1</span>) &#123;<br>                        grid[newX][newY] = <span class="hljs-number">2</span>;<br>                        que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newX, newY&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 统计不能到达边界的数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) res++; <span class="hljs-comment">// 为1的就是无法到达边界的陆地</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>3.DFS解法：4ms 48.7 MB</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] canReach;  <span class="hljs-comment">// canReach记录grid[i][j]是否能到达边界</span><br>    <span class="hljs-type">int</span>[][] grid;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] _grid)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        记忆化DFS:</span><br><span class="hljs-comment">        有一个技巧，要越过边界一定要经过边界，那么我们要求中间有哪些不能到达边界的，反过来就是要求哪些能到达边界的</span><br><span class="hljs-comment">        再反过来只需要从边界开始DFS看看能到达哪些陆地即可，再用总的陆地数减去能到达边界的陆地数就是不能到达的陆地数</span><br><span class="hljs-comment">         */</span><br>        grid = _grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        canReach = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-comment">// 搜索4条边界的陆地</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) dfs(i, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (grid[i][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) dfs(i, n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) dfs(<span class="hljs-number">0</span>, j);<br>            <span class="hljs-keyword">if</span> (grid[m - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) dfs(m - <span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-comment">// 统计不能到达边界的数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !canReach[i][j]) res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// dfs(i,j)搜索与之连接的陆地并标记到canReach</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// grid[i][j]可以到达边界说明与之连通的已经搜索过了，结束</span><br>        <span class="hljs-keyword">if</span> (canReach[i][j]) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 标记与边界连通</span><br>        canReach[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 搜索4个方向</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newI</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], newJ = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 位于区域内并且是陆地就可以到达</span><br>            <span class="hljs-keyword">if</span> (newI &gt;= <span class="hljs-number">0</span> &amp;&amp; newI &lt;= m - <span class="hljs-number">1</span> &amp;&amp; newJ &gt;= <span class="hljs-number">0</span> &amp;&amp; newJ &lt;= n - <span class="hljs-number">1</span> &amp;&amp; grid[newI][newJ] == <span class="hljs-number">1</span>) &#123;<br>                dfs(newI, newJ);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1162-地图分析">2.<a href="https://leetcode.cn/problems/as-far-from-land-as-possible/"><strong>1162. 地图分析</strong></a></h3><p><strong>多源BFS实际就是单源BFS的第二层，在前面加上一个超级源点指向最初入队的节点，就是普通的单源BFS</strong></p><p><strong>参考：</strong><a href="https://leetcode.cn/problems/as-far-from-land-as-possible/solution/zhen-liang-yan-sou-huan-neng-duo-yuan-kan-wan-miao/"> <strong>ʚ自在飞花ɞ | 多个源点的广搜</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        多源BFS问题(相当于单源BFS从第2层开始):</span><br><span class="hljs-comment">        这题是最短路径问题，求某个0到达1的最短路径的最大值</span><br><span class="hljs-comment">        求最短路径，首先想到的就是BFS，可以枚举每个格子0求出每个海洋到达陆地的最近距离，取最大值</span><br><span class="hljs-comment">        这样做的时间复杂度为O(n^4)≈1e8 必定TLE</span><br><span class="hljs-comment">        不妨反过来，我们从陆地1出发进行多源点的BFS</span><br><span class="hljs-comment">        每一圈到达的海洋0都是陆地到达的该海洋的最短路径，也就是说是这个海洋到达陆地的最短路径</span><br><span class="hljs-comment">        那么遍历到最后一层就是陆地1到达海洋0的最短路径最大值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 所有的陆地入队(相当于单源BFS的第二层)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 全是海洋或者陆地返回-1</span><br>        <span class="hljs-keyword">if</span> (que.size() == m * n || que.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span>[] poll = que.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], y = poll[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dir[<span class="hljs-number">0</span>], newY = y + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// grid[newX][newY]在区域内且为没有被访问过的海洋</span><br>                    <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt;= m - <span class="hljs-number">1</span> &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt;= n - <span class="hljs-number">1</span> &amp;&amp; grid[newX][newY] == <span class="hljs-number">0</span>) &#123;<br>                        grid[newX][newY] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 访问过的海洋记为2就不会重复访问</span><br>                        que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newX, newY&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            dis++;  <span class="hljs-comment">// 每一圈距离+1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dis;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在矩阵中，关于BFS入队的类型，可以为int[] 类型的[x,y]，也可以将其化为int类型后面再进行解析</strong></p><h3 id="3-1765-地图中的最高点">3.<a href="https://leetcode.cn/problems/map-of-highest-peak/"><strong>1765. 地图中的最高点</strong></a></h3><p><strong>1.常规写法：44 ms  136.9 MB</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] highestPeak(<span class="hljs-type">int</span>[][] isWater) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        多源BFS：</span><br><span class="hljs-comment">        矩阵就是4方向的无向图</span><br><span class="hljs-comment">        这题要求的是从某个水域1出发后的BFS的层数能达到的方案值对应的矩阵，且任意相邻的格子高度差 至多 为 1</span><br><span class="hljs-comment">        多源的BFS解法就是首先让可以入队的水域1全部一次入队，遇到下一个格子直接等于本格子的值+1</span><br><span class="hljs-comment">        遍历完之后会出现最大值，最后的矩阵就是答案</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> isWater.length, n = isWater[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 这里规定为水域为0，没有访问的土地为-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (isWater[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    isWater[i][j] = <span class="hljs-number">0</span>;<br>                    que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    isWater[i][j] = -<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span>[] poll = que.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], y = poll[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dir[<span class="hljs-number">0</span>], newY = y + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 在区域内且没有被访问过的土地才能BFS</span><br>                    <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt;= m - <span class="hljs-number">1</span> &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt;= n - <span class="hljs-number">1</span> &amp;&amp; isWater[newX][newY] == -<span class="hljs-number">1</span>) &#123;<br>                        isWater[newX][newY] = isWater[x][y] + <span class="hljs-number">1</span>;<br>                        que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newX, newY&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isWater;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>化为int类型后：45 ms 158.2 MB</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] highestPeak(<span class="hljs-type">int</span>[][] isWater) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> isWater.length, n = isWater[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>        Queue&lt;Integer&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();    <span class="hljs-comment">// 用int代替[x,y]数组</span><br>        <span class="hljs-comment">// 这里规定为水域为0，没有访问的土地为-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (isWater[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    isWater[i][j] = <span class="hljs-number">0</span>;<br>                    que.add(i * n + j);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    isWater[i][j] = -<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> que.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll / n, y = poll % n; <span class="hljs-comment">// 解析出x与y</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dir[<span class="hljs-number">0</span>], newY = y + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 在区域内且没有被访问过的土地才能BFS</span><br>                    <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt;= m - <span class="hljs-number">1</span> &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt;= n - <span class="hljs-number">1</span> &amp;&amp; isWater[newX][newY] == -<span class="hljs-number">1</span>) &#123;<br>                        isWater[newX][newY] = isWater[x][y] + <span class="hljs-number">1</span>;<br>                        que.add(newX * n + newY);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isWater;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多源BFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈总结</title>
      <link href="/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93.html"/>
      <url>/%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-单调栈可以解决的问题：">1.单调栈可以解决的问题：</h3><p>我们常常遇到要在O(N)的时间复杂度内求出当前对象 nums[i] 左边或者右边首个比自己大或者小的情况</p><p>这种问题通常称为<strong>Next Greater问题</strong></p><p>就相当于你是一个人，往两边看首先被哪个高个子挡住，这个高个子满足两个条件：</p><p>1.身高比你高；2.在某一方向中比你高的人中距离你最近</p><p>这种条件可能比较明显，<a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a>  <a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a> 这类型要你直接求下一个更大更小的元素是什么</p><p>也有可能是比较隐秘的，抽象成<strong>波及范围</strong>的，这属于单调栈中的困难题了 <a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>  <a href="https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/">6119. 元素值大于变化阈值的子数组</a></p><p>求某个元素的影响范围，通常都是找到两边首个比自己小的或大的 left 与 right，然后这个[left,right]通常就是影响区间的</p><p>例如[left,right]可以接住高度为max-nums[i]的雨水，可以组成某某区间等…</p><h3 id="2-单调栈的两种写法：">2.单调栈的两种写法：</h3><p>以<a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a> 为例进行说明，一般来说有两种写法：</p><p>1.<strong>Next Greater元素</strong>在栈中的写法（25ms/51.1MB）</p><p>举个🌰：现在要寻找的nums[i]左边首个严格小于nums[i]的元素，st = [1, 2, 3, 6]</p><p>若nums[i]=7，直接取栈顶的6作为左边首个严格小于nums[i]的元素</p><p>若nums[i]=3，要将栈顶中&gt;=nums[i]的元素全部弹出，直至栈顶严格小于nums[i] 此时st = [1, 2]，那么2就是所求</p><p><strong>要点：</strong> 如果找nums[i] 右边的元素，那么从右边遍历起以便于 Next Greater元素先入栈；</p><p>反之，如果找nums[i] 左边的元素，那么从左边遍历起以便于 Next Greater元素先入栈；</p><p>当前遍历到的nums[i]就是基准元素，如果找右边首个大于nums[i]的就要一直保持nums[i]是最左边的且是最小的，不符合条件的栈顶元素（&lt;=nums[i]的）就出栈，直到符合条件就找到了答案。</p><p><img src="../images/p8.jpg" alt="p8"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] tem) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        写法1:Next Greater元素在栈中的写法</span><br><span class="hljs-comment">        我们要找nums[i]右边首个比自身严格大的温度，因此要从右边起遍历温度</span><br><span class="hljs-comment">        并且维护一个严格单调递增的栈（从左往右看）</span><br><span class="hljs-comment">        单调找的操作有如下两种选择：</span><br><span class="hljs-comment">        1.tem[i]&lt;tem[栈顶] 说明找到tem[i]右边首个比自身大的温度，直接记录，最后tem[i]也要入栈</span><br><span class="hljs-comment">        2.tem[i]&gt;=tem[栈顶] 说明栈顶不是符合要求的元素，逐个弹出直至tem[i]&lt;tem[栈顶]，记录结果，最后tem[i]也要入栈</span><br><span class="hljs-comment">        特殊情况：栈为空直接入栈</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tem.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 单调栈存储索引即可</span><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// tem[i]&gt;=tem[栈顶] 弹出栈顶元素直至tem[i]&lt;tem[栈顶]</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; tem[i] &gt;= tem[stack.peekFirst()]) stack.pollFirst();<br>            <span class="hljs-comment">// 记录结果:栈为空说明tem[i]后面没有比tem[i]温度高的，记录0；否则记录天数差值</span><br>            res[i] = stack.isEmpty() ? <span class="hljs-number">0</span> : stack.peekFirst() - i;<br>            <span class="hljs-comment">// tem[i]入栈</span><br>            stack.addFirst(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.<strong>基准元素nums[i]</strong> 在栈中的写法(23ms/56.8MB)</p><p>举个🌰：现在要寻找的nums[i]右边首个严格大于nums[i]的元素，st = [8, 6, 4, 3]</p><p>现在我们栈中的元素还要找自己右边首个大于自己的元素呢，嗷嗷待哺~~~</p><p>若nums[i]=2，比栈顶还小，直接入栈得了，所有人都还没找到比自己小的元素~~~此时 st = [8, 6, 4, 3, 2]</p><p>此时来了nums[i]=4，栈上方的2与3显然是找到了右边首个比自己严格大的元素，出栈并记录</p><p>但是栈中的4还是没有找到比自己严格大的，因此只能期待接下来有没有更大的数字了~~~</p><p>此时st = [8, 6, 4, 4] 若此时再来个5那么这两个可怜的4就有机会出栈并记录了~~~</p><p><strong>要点：</strong> 如果找nums[i] 右边的元素，那么从左边遍历起以便于基准元素nuns[i]先入栈；</p><p>反之，如果找nums[i] 左边的元素，那么从右遍历起以便于基准元素nums[i]先入栈；</p><p>当前遍历到的nums[i]就是基准元素，且一直要保持栈顶是最小的，一旦新来的nums[i]严格大于栈顶的小可怜，就代表栈顶的小可怜可以出栈记录了</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] tem) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    写法2:基准元素nums[i]在栈中的写法</span><br><span class="hljs-comment">    我们要找nums[i]右边首个比自身严格大的温度，因此要从左起遍历温度以便于基准元素入栈</span><br><span class="hljs-comment">    维护一个单调递减栈（从左往右看） 一旦栈顶小可爱遇到比自己大的就冲出来并记录</span><br><span class="hljs-comment">    1.tem[i]&lt;=tem[栈顶] 说明栈顶的小可爱都还没找到下一个比自己严格大的元素，tem[i]直接入栈当下一个小可爱</span><br><span class="hljs-comment">    2.tem[i]&gt;tem[栈顶] 说明栈顶那群小可爱已经找到下一个比自己严格大的元素，出栈并记录，最后别忘了tem[i]也要入栈找自己的下一个比自身大的元素</span><br><span class="hljs-comment">    特殊情况：栈为空直接入栈即可，栈顶没有人要找下一个更大的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tem.length;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// 单调栈存储索引即可</span><br>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 当栈顶小可爱遇到比自己大的tem[i]，c出栈并记录后tem[i]入栈</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; tem[i] &gt; tem[stack.peekFirst()]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> stack.pollFirst();<br>            res[poll] = i - poll;<br>        &#125;<br>        <span class="hljs-comment">// 否则直接入栈</span><br>        stack.addFirst(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>由运行结果可知两种写法时间消耗与空间消耗接近，个人比较推荐<strong>写法1</strong></p><h3 id="3-API的选用习惯：">3.API的选用习惯：</h3><p>目前比较推荐以下两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">写法1</span><br><span class="hljs-comment">*/</span><br>Deque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>st.push(i);    <span class="hljs-comment">// 元素入栈</span><br>st.peek();    <span class="hljs-comment">// 查看栈顶元素</span><br>st.pop();    <span class="hljs-comment">// 弹出栈顶元素</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">写法2</span><br><span class="hljs-comment">*/</span><br>Deque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>st.addFirst(i);    <span class="hljs-comment">// 元素入栈</span><br>st.peekFirst();    <span class="hljs-comment">// 查看栈顶元素</span><br>st.pollFirst();    <span class="hljs-comment">// 弹出栈顶元素</span><br></code></pre></td></tr></table></figure><h3 id="4-单调栈与范围管辖问题（Hard）">4.单调栈与范围管辖问题（Hard）</h3><p><a href="https://leetcode.cn/problems/sum-of-subarray-ranges/"><strong>2104. 子数组范围和</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">subArrayRanges</span><span class="hljs-params">(<span class="hljs-type">int</span>[] _nums)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    方法2：单调栈</span><br><span class="hljs-comment">    我们要找nums[i]中所有的子数组的max-min的和，那么我们罗列出所有子数组，其最大值和最小值必定出自于nums[i]其中某一个</span><br><span class="hljs-comment">    换一个角度，我们假设nums[i]作为max管辖的子数组个数为k1，最为min管辖的子数组个数为k2，那么nums[i]*(k2-k1)就是nums[i]这个数字贡献的范围和</span><br><span class="hljs-comment">    我们怎样知道某个nums[i]的管辖范围？很显然要找到nums[i]在包含自身的哪个范围内是“老大”</span><br><span class="hljs-comment">    例如作为max就要知道自己左右两边首个比自己大的数字，在这两个数字之间nums[i]就是老大</span><br><span class="hljs-comment">    这种情况显然就要用到单调找来查找自己的管辖范围</span><br><span class="hljs-comment">    以求最大值为例进行说明，我们要求自己左右两边比自己大的数字，先以左边为例进行说明</span><br><span class="hljs-comment">    在栈中从左到右维护一个单调递减栈，一旦遇到nums[i]&lt;nums[栈顶]就说明nums[i]找到了比自己大的数字位置</span><br><span class="hljs-comment">    找到nums[i]左右两边比自己大的数字位置之后，例如 nums = [4,-2,-3,4,1] 计算得idx=3的元素范围为[-1,5]</span><br><span class="hljs-comment">    这里是下一个比自己大的数字范围，因此包含idx=3的子数组个数为：(3-(-1))*(5-3)=8 左边4个:3  2,3  1,2,3  0,1,2,3</span><br><span class="hljs-comment">    右边2个:∅  4 换算到一般情况就是 (idx-left)*(right-idx)</span><br><span class="hljs-comment">    注意点：nums = [4,-2,-3,4,1] 这种情况下我们会求得第一个4的范围为：[0,4] 同理第二个范围也为：[0,4]</span><br><span class="hljs-comment">    这两种情况会重复计算第一个4与第二个4共存的情况</span><br><span class="hljs-comment">    因此我们在单调栈计算的时候，约定左边找比自己严格大(小)的首个数字，右边找大于等于(小于等于)自己的首个数字</span><br><span class="hljs-comment">    时间复杂度:O(N) 空间复杂度:O(N)</span><br><span class="hljs-comment">     */</span><br>    nums = _nums;<br>    n = nums.length;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// max[i]表示nums[i]作为最大值的子数组个数，min[i]表示nums[i]作为最小值的子数组个数</span><br>    <span class="hljs-type">int</span>[] max = getCnt(<span class="hljs-literal">true</span>), min = getCnt(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 计算所有子数组范围和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res += (<span class="hljs-type">long</span>) (max[i] - min[i]) * nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// getCnt(true)表示获取nums[i]最大值的子数组个数，反之就是获取nums[i]最大值的子数组个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] getCnt(<span class="hljs-type">boolean</span> isMax) &#123;<br>    <span class="hljs-comment">// ans[i]表示要返回的数据</span><br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// left[i]表示nums[i]左边首个严格大于(小于)自身的数字索引</span><br>    <span class="hljs-comment">// right[i]表示nums[i]左边首个非严格大于(小于)自身的数字索引</span><br>    <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// 利用单调栈查找管辖范围</span><br>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; (isMax ? nums[i] &gt;= nums[stack.peekFirst()] : nums[i] &lt;= nums[stack.peekFirst()])) stack.pollFirst();<br>        left[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peekFirst();<br>        stack.addFirst(i);<br>    &#125;<br>    stack.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; (isMax ? nums[i] &gt; nums[stack.peekFirst()] : nums[i] &lt; nums[stack.peekFirst()])) stack.pollFirst();<br>        right[i] = stack.isEmpty() ? n : stack.peekFirst();<br>        stack.addFirst(i);<br>    &#125;<br>    <span class="hljs-comment">// 计算管辖范围内子数组个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans[i] = (i - left[i]) * (right[i] - i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/"><strong>2334. 元素值大于变化阈值的子数组</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">validSubarraySize</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> threshold)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        单调栈的应用:</span><br><span class="hljs-comment">        不妨枚举nums[i]并假设某包含nums[i]的子段是长度为k的某段中最小的数字</span><br><span class="hljs-comment">        在该段中其余数字都大于nums[i]，只要nums[i]&gt;threshold/k，那么段内的所有元素均大于threshold/k</span><br><span class="hljs-comment">        我们只需要求出有没有这样的nums[i]就可以知道是否有符合题意的k</span><br><span class="hljs-comment">        怎样维护某个nums[i]在某个段内是最小的数字？我们只需要找到nums[i]左边和右边首个严格小于nums[i]的索引</span><br><span class="hljs-comment">        那么索引之间就是nums[i]这段的波及范围</span><br><span class="hljs-comment">        快速求nums[i]左边和右边首个小于nums[i]的元素属于Next Greater问题，可以用单调栈解决</span><br><span class="hljs-comment">        时间复杂度：O(N) 空间复杂度：O(N)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 两个单调栈st1与st2</span><br>        Deque&lt;Integer&gt; st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), st2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// left[i]存储nums[i]左边首个严格小于nums[i]的数字索引，不存在时为-1</span><br>        <span class="hljs-comment">// right[i]存储nums[i]右边首个严格小于nums[i]的数字索引，不存在时为n</span><br>        <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 正序遍历求left[i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 遇到nums[i]&lt;=nums[栈顶索引] -&gt; 弹出栈顶索引直至nums[i]&gt;nums[栈顶索引]</span><br>            <span class="hljs-comment">// 此时nums[栈顶索引]就是nums[i]左边首个严格小于nums[i]的数字</span><br>            <span class="hljs-comment">// 被弹出的那些栈顶元素是不可能成为后面left[i]有效取值的，因为会优先取到当前的nums[i]</span><br>            <span class="hljs-comment">// e.g. nums[st1]=[1,2,4,5] nums[i]=3 显然4与5不符合题意弹出 3才是符合题意的 加入后面有个6进来了</span><br>            <span class="hljs-comment">// 必然会优先取到3而不会取更前面的4与5</span><br>            <span class="hljs-keyword">while</span> (!st1.isEmpty() &amp;&amp; nums[st1.peek()] &gt;= nums[i]) st1.pop();    <span class="hljs-comment">// 一直弹出直至st1严格递增</span><br>            left[i] = st1.isEmpty() ? -<span class="hljs-number">1</span> : st1.peek();  <span class="hljs-comment">// 栈顶的必定1严格小于nums[i]并且是最近的(-1表示取全部)</span><br>            st1.push(i);    <span class="hljs-comment">// 每次都要入栈</span><br>        &#125;<br>        <span class="hljs-comment">// 倒序遍历求right[i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!st2.isEmpty() &amp;&amp; nums[st2.peek()] &gt;= nums[i]) st2.pop();<br>            right[i] = st2.isEmpty() ? n : st2.peek();<br>            st2.push(i);<br>        &#125;<br>        <span class="hljs-comment">// 枚举nums[i]根据其波及范围确定到k，再判断k是否合法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> right[i] - left[i] - <span class="hljs-number">1</span>; <span class="hljs-comment">// 实际范围:[left[i]+1,right[i]-1]</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; threshold / k) <span class="hljs-keyword">return</span> k;  <span class="hljs-comment">// 合法</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 不存在</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-栈结构写法的优化">5.栈结构写法的优化</h3><p>以<a href="https://leetcode.cn/problems/sum-of-subarray-ranges/"><strong>2104. 子数组范围和</strong></a>为例进行说明</p><p>栈结构还可以优化成数组的写法，辅助一个ptr指针，在数据范围小的时候非常节省时间与空间</p><p>其中<strong>ptr指代当前栈中栈顶元素所在stack数组的位置</strong></p><p>prt指针可以初始化为-1或者0表示栈底索引，栈的容量初始化为可能出现的最大栈中元素个数</p><p><strong>入栈：</strong> stack[++ptr]=i腾出空位再赋值</p><p><strong>出栈：</strong> 直接ptr–即可，后面新元素入栈会覆盖掉旧的痕迹</p><p><strong>查看栈顶元素：</strong> 返回stack[ptr]就是</p><p><strong>清空栈：</strong> ptr=0（-1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">subArrayRanges</span><span class="hljs-params">(<span class="hljs-type">int</span>[] _nums)</span> &#123;<br>    nums = _nums;<br>    n = nums.length;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// max[i]表示nums[i]作为最大值的子数组个数，min[i]表示nums[i]作为最小值的子数组个数</span><br>    <span class="hljs-type">int</span>[] max = getCnt(<span class="hljs-literal">true</span>), min = getCnt(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 计算所有子数组范围和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res += (<span class="hljs-type">long</span>) (max[i] - min[i]) * nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// getCnt(true)表示获取nums[i]最大值的子数组个数，反之就是获取nums[i]最大值的子数组个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] getCnt(<span class="hljs-type">boolean</span> isMax) &#123;<br>    <span class="hljs-comment">// ans[i]表示要返回的数据</span><br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// left[i]表示nums[i]左边首个严格大于(小于)自身的数字索引</span><br>    <span class="hljs-comment">// right[i]表示nums[i]左边首个非严格大于(小于)自身的数字索引</span><br>    <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// 利用单调栈查找管辖范围(数组模拟栈结构，在范围小得时候非常好用)</span><br>    <span class="hljs-type">int</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// ptr指代当前栈中栈顶元素所在stack数组的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (ptr &gt; <span class="hljs-number">0</span> &amp;&amp; (isMax ? nums[i] &gt;= nums[stack[ptr]] : nums[i] &lt;= nums[stack[ptr]])) ptr--;<br>        left[i] = ptr == <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : stack[ptr];<br>        stack[++ptr] = i;<br>    &#125;<br>    ptr = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 清空栈</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (ptr &gt; <span class="hljs-number">0</span> &amp;&amp; (isMax ? nums[i] &gt; nums[stack[ptr]] : nums[i] &lt; nums[stack[ptr]])) ptr--;<br>        right[i] = ptr == <span class="hljs-number">0</span> ? n : stack[ptr];<br>        stack[++ptr] = i;<br>    &#125;<br>    <span class="hljs-comment">// 计算管辖范围内子数组个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans[i] = (i - left[i]) * (right[i] - i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-记录的一些练习题">6.记录的一些练习题</h3><h4 id="6-1-LC402-移掉-K-位数字"><a href="https://leetcode-cn.com/problems/remove-k-digits/"><strong>6.1 LC402. 移掉 K 位数字</strong></a></h4><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>请你以字符串形式返回这个最小的数字。</p><p><img src="../images/p24.jpg" alt="p24"></p><p><strong>思路：</strong></p><p><strong>单调栈</strong>:维护一个栈底-&gt;栈顶单调递增的栈(参考&quot;笨猪爆破组&quot;题解)</p><p>要尽量让高位维护一个递增的趋势，即去除高位的降序对</p><p>如:1234532与5321234，当组成数字相同时，必定是前面高位递增数值会更加小</p><p>现在任务变成：删除k位使得高位的递增序列尽量长(删除高位尽可能多的递减对)</p><p>单调栈按顺序存储想要的数字，其中栈顶为栈中最大值，将当前遍历到的数字与栈顶比较决定栈顶的去留</p><p>设栈顶数字为B，当前遍历到的数字为A：</p><p>1.B &gt; A：B与A之间组成递减对，此时去掉B，A代替B的位置可以使得数值变小</p><p>2.B &lt;= A：B与A之间组成递增对，让A入栈是最好的选择</p><p>这里要注意几个问题：</p><p>1.能去除（出栈）的数字个数有限，不能超过k，因此超过k部分直接加入，不保证栈的单调性</p><p>2.考虑去除前导0的情况，前导0不能加入；换句话说就是：非0和有垫底的0可以加入</p><p>3.当前num中的降序对 &lt; k时，删除完所有降序对后，num已经是递增，此时截取前面部分就是最小的;</p><p>4.当前num中的降序对 &gt;= k时，恰好删除完或者有剩余，此时num后面的直接加入即可，不用考虑保持栈的单调性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num.length() == k) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 单调栈</span><br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 遍历num每一个数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : num.toCharArray()) &#123;<br>            <span class="hljs-comment">// 找出降序对</span><br>            <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peekFirst() &gt; ch) &#123;<br>                <span class="hljs-comment">// 这里弹出一个表明num中删除了一个(降序对的前一个元素)</span><br>                stack.pollFirst();<br>                k--;<br>            &#125;<br>            <span class="hljs-comment">// 为了去除前导0:非0的直接加入;当前栈有垫底的,啥都可以加入</span><br>            <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">&#x27;0&#x27;</span> || !stack.isEmpty()) stack.addFirst(ch);<br>        &#125;<br>        <span class="hljs-comment">// 遍历完num所有数字,但是k还大于0,要截取前面的数字(相当于把栈顶部分弹出k个)</span><br>        <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span> &amp;&amp; !stack.isEmpty()) stack.pollFirst();<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) sb.append(stack.pollFirst());<br>        <span class="hljs-comment">// 这里要考虑到栈为空的情况,sb没东西表明为0</span><br>        <span class="hljs-keyword">return</span> sb.length() == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;0&quot;</span> : sb.reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-2-LC316-去除重复字母"><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/"><strong>6.2 LC316. 去除重复字母</strong></a></h4><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。</p><p>需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p><img src="../images/p25.jpg" alt="p25"></p><p><strong>思路：</strong></p><p><strong>单调栈+标记:</strong></p><p>参考labuladong的题解，本题的关键点有几个：</p><p>1.要求最后的字母没有重复，且每个字母都要出现一次</p><p>2.要按照原来字母的出现顺序输出(相对顺序不变)</p><p>3.满足条件1与2前提下的要求返回字符串的字典序最小</p><p>其中，条件1可以用boolean数组或者HashSet等数据结构来进行存储，如果前面出现过就不加入；</p><p>条件2要求相对顺序不变，可以用一个指针进行遍历再存储，只要满足数据存储有序的数据结构即可</p><p>最关键的是条件3，要求字典序最小的情形输出。这里就是要用到单调栈最深层的原因</p><p>因为我们要操作&quot;临近元素&quot;(降序对)！为什么要操作降序对？</p><p>这个可以参考  402. 移掉 K 位数字(中等)</p><p>402题是要求删掉k个数字使得最后的结果最小，核心就是优先找出&quot;降序对&quot;，例如：76，98，54…</p><p>因为当你删除了降序对前面的数字后，后面数字的居上取代了原来前面的数字，必定使得数字变小</p><p>A=123a56与B=123b56，a与b当前面完全一致，整个数字大小取决于a与b的大小，a&gt;b则A&gt;B</p><p>回到本题中，我们要使得字典序在满足其他条件的前提下尽可能小，那么可以选择删掉降序对的前面字母</p><p>由于后来居上的特征，降序对是不断变化的，因此要用<strong>栈</strong>这种结构来模拟，每当当前字母ch满足其他条件时，</p><p>如果与栈顶组成降序对，说明我现在<strong>有机会</strong>让字典序变小，因此必然会想着将栈顶元素弹出！</p><p>可是本题要求所有字母都要出现一次，你把栈顶弹出了之后万一后面不再出现栈顶的字母不就不满足题意？</p><p>因此还要看看后面有没有再出现栈顶元素：</p><p>1.若没有出现则不能弹出，ch乖乖进去吧！</p><p>2.若后面还会出现，可以放心弹出，后面还可以加入该字母的，这样既使得字典序尽量小又能满足条件！</p><p>做法就是用count数组维护当前位置后面剩余的每个字母个数，当个数减为0时说明后面没有了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicateLetters</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 统计当前位置剩余字符的个数</span><br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            count[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">// 统计某个字母是否在栈中(用于栈中去重)</span><br>        <span class="hljs-type">boolean</span>[] inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">// 单调栈:按照字母的字典序保存字母</span><br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 遍历字符串s</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-comment">// 字符c次数-1</span><br>            count[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-comment">// 栈中已经有了,不再加入</span><br>            <span class="hljs-keyword">if</span>(inStack[c - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 字符c入栈,入栈前要将所有的字典序比c大且后面还会出现的字母弹出</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; c &lt; stack.peekFirst()) &#123;<br>                <span class="hljs-comment">// 栈顶字母后面没有出现了,不能再弹出</span><br>                <span class="hljs-keyword">if</span>(count[stack.peekFirst() - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 否则可以弹出</span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> stack.pollFirst();<br>                <span class="hljs-comment">// 弹出的就将栈中的记录删除</span><br>                inStack[poll - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 字符c入栈</span><br>            stack.addFirst(c);<br>            <span class="hljs-comment">// 入栈后要标记</span><br>            inStack[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 最后将栈中的元素逐个弹出存入sb中</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            sb.append(stack.pollFirst());<br>        &#125;<br>        <span class="hljs-comment">// 还要倒序一下才是正确顺序</span><br>        <span class="hljs-keyword">return</span> sb.reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试题 03.02. 栈的最小值 同 155.最小栈</strong></p><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><p>MinStack() 初始化堆栈对象。</p><p>void push(int val) 将元素val推入堆栈。</p><p>void pop() 删除堆栈顶部的元素。</p><p>int top() 获取堆栈顶部的元素。</p><p>int getMin() 获取堆栈中的最小元素。</p><p><img src="../images/p26.jpg" alt="p26"></p><p><strong>思路：</strong></p><p><strong>单调递增栈</strong>(栈顶-&gt;栈底)维护栈中元素最小值:</p><p>方法1：完全同步栈：一个为常规栈（主栈）；另一个为同步栈，保存每一步中主栈元素最小值</p><p>这个方法要求主栈与同步栈的元素个数严格相等，加入时两个同步加入，弹出时两个同步弹出，无需多加判断</p><p>这种方法存在一定的冗余存储，于是就有了方法2</p><p>方法2：主栈+单调栈：一个为主栈，另一个为单调递增栈(栈顶-&gt;栈底)，当且仅当要加入的元素x&lt;=单调栈栈顶时才加入</p><p>其余情况不加入；同理，弹出时要看单调栈栈顶是否与主栈弹出的元素相等，若相等的话就弹出。</p><p>注意：这个单调栈是非主动挤压型的，也就是在加入元素时，如果当前元素不能与现在的单调栈构成单调递增栈会主动放弃，而不会将栈中不符合条件的全部弹出(这显然会损失掉部分最小值信息!)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack_1</span> &#123;<br>    Deque&lt;Integer&gt; stack;<br>    Deque&lt;Integer&gt; minStack;<br>    <span class="hljs-comment">// 构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack_1</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 这一步很关键:就是让首个加入的x也可以顺利加入minStack</span><br>        minStack.addFirst(Integer.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-comment">// 往栈顶加入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 常规栈直接加入,最小栈加入当前栈中最小值(统一以队头为栈顶)</span><br>        stack.addFirst(x);<br>        <span class="hljs-comment">// 求出当前栈中的最小值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(minStack.peekFirst(), x);<br>        minStack.addFirst(min);<br>    &#125;<br><br>    <span class="hljs-comment">// 弹出栈顶元素(不返回)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 常规栈直接弹出,最小栈同步更新</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pollFirst();<br>        <span class="hljs-comment">// 这里无论pop是何止都要弹出minStack栈顶,因为两个栈的个数总是一致的</span><br>        minStack.pollFirst();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈顶元素(不弹出)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peekFirst();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈中最小值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peekFirst();<br>    &#125;<br>&#125;<br>----------------------------------------------------------------------------------------------------------------<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack_2</span> &#123;<br>    Deque&lt;Integer&gt; stack;<br>    Deque&lt;Integer&gt; minStack;<br>    <span class="hljs-comment">// 构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack_2</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 这一步很关键:就是让首个加入的x也可以顺利加入minStack</span><br>        minStack.addFirst(Integer.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-comment">// 往栈顶加入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 常规栈直接加入,最小栈加入当前栈中最小值(统一以队头为栈顶)</span><br>        stack.addFirst(x);<br>        <span class="hljs-comment">// 求出当前栈中的最小值</span><br>        <span class="hljs-keyword">if</span>(x &lt;= minStack.peekFirst()) minStack.addFirst(x);<br>    &#125;<br><br>    <span class="hljs-comment">// 弹出栈顶元素(不返回)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 常规栈直接弹出,最小栈同步更新</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pollFirst();<br>        <span class="hljs-comment">// 区别就在这里:这里要看与pop相等的栈顶才弹出</span><br>        <span class="hljs-keyword">if</span>(minStack.peekFirst() == pop) minStack.pollFirst();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈顶元素(不弹出)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peekFirst();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈中最小值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peekFirst();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>这道题要时刻注意判空异常，还有初始化辅助栈要将不影响首个元素入栈的Integer.MAX_VALUE加入!!!记住了</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀树Tire</title>
      <link href="/%E5%89%8D%E7%BC%80%E6%A0%91Tire.html"/>
      <url>/%E5%89%8D%E7%BC%80%E6%A0%91Tire.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/"> <strong>208.实现Trie (前缀树)</strong></a></p><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于<strong>高效地存储和检索字符串数据集中的键</strong>。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p><strong>代码模板如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    总体思路:</span><br><span class="hljs-comment">    1.创建节点类:TireNode 包含2个成员:</span><br><span class="hljs-comment">        1.boolean end-&gt;标记该节点是否为单词末尾</span><br><span class="hljs-comment">        2.TireNode[26] children 孩子触手指向接下来的字母节点</span><br><span class="hljs-comment">    2.通过这个TireNode类进行保存、查找与查询前缀的操作</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TireNode</span> &#123;<br>        <span class="hljs-type">boolean</span> end;    <span class="hljs-comment">// 标记该节点是否为单词末尾</span><br>        TireNode[] children;    <span class="hljs-comment">// 孩子触手指向接下来的字母节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireNode</span><span class="hljs-params">()</span> &#123;<br>            end = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 默认不是结尾</span><br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 保存字母26只触手即可</span><br>        &#125;<br>    &#125;<br><br>    TireNode root;  <span class="hljs-comment">// Tire根节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 向前缀树中插入字符串 word</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root; <span class="hljs-comment">// p指针从Tire根节点开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;   <span class="hljs-comment">// word[i]对应触手索引</span><br>            <span class="hljs-keyword">if</span> (p.children[u] == <span class="hljs-literal">null</span>) p.children[u] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();  <span class="hljs-comment">// 没有对应字母节点就创建</span><br>            p = p.children[u];  <span class="hljs-comment">// 往下走</span><br>        &#125;<br>        p.end = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 标记p这里是结尾</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.children[u] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 没有该单词</span><br>            p = p.children[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p.end;   <span class="hljs-comment">// 如果当初p标记了结尾说明就是存在该单词</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> prefix.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.children[u] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p.children[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 能走完就表明存在该前缀,不一定要为end==true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tire </tag>
            
            <tag> 前缀树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列DP专题</title>
      <link href="/%E5%BA%8F%E5%88%97DP%E4%B8%93%E9%A2%98.html"/>
      <url>/%E5%BA%8F%E5%88%97DP%E4%B8%93%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-最长递增子序列（LIS问题）">1.最长递增子序列（LIS问题）</h3><p><a href="https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/"><strong>1713. 得到子序列的最少操作次数</strong></a></p><p>这道题提供提供了一种时间复杂度为<strong>O(NlogN)</strong> 的方法求解最长递增子序列的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] target, <span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        从最长公共子序列问题(LCS)转化为最长递增子序列(LIS)问题</span><br><span class="hljs-comment">        如:target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]</span><br><span class="hljs-comment">        映射到map后:[6-&gt;0,4-&gt;1,8-&gt;2,1-&gt;3,3-&gt;4,2-&gt;5]</span><br><span class="hljs-comment">        则arr的索引为:[1,-1,0,5,4,2,0,3] 可以将-1去掉得到 [1,0,5,4,2,0,3]</span><br><span class="hljs-comment">        变相就是求映射后的arr最长严格递增子序列长度,最后答案是target长度-arr最长递增子序列长度</span><br><span class="hljs-comment">        由于arr范围在1e5 因此用O(N^2)办法必定TLE</span><br><span class="hljs-comment">        尝试维护一个数组minTail[i]记录长度为i的递增子序列结尾的最小数字</span><br><span class="hljs-comment">        显然minTail是单调递增的,因为递增序列长度越大,其最小结尾数字必然越大</span><br><span class="hljs-comment">        此时可以用二分加速搜索f[i]前面的最佳转移项f[j],f[j]必定满足条件:结尾数值&lt;list[i]并且长度最大</span><br><span class="hljs-comment">        我们寻找结尾元素&lt;list[i]的最大长度项,即结尾元素&lt;list[i]的最大minIdx索引</span><br><span class="hljs-comment">        注意:</span><br><span class="hljs-comment">        1.这是边遍历list[i]边更新minTail[i],因此都是list[i]前面的索引</span><br><span class="hljs-comment">        2.由于LCS是没有重复元素的因此转化为LIS问题后是严格递增的</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> target.length;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 将target元素及索引映射到map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        map.put(target[i], i);<br>    &#125;<br>    <span class="hljs-comment">// 存储arr在target中的有效索引</span><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(num)) list.add(map.get(num));<br>    &#125;<br>    <span class="hljs-comment">// 此时问题转化为求list中最长严格递增子序列长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size(), max = <span class="hljs-number">0</span>;   <span class="hljs-comment">// max维护当前遍历的最长递增子序列长度(list可能为空因此max初始化为0)</span><br>    <span class="hljs-comment">// f[i]为以list[i]结尾的最长递增子序列长度,minTail[i]为长度为i的递增子序列对应的最小结尾数字</span><br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], minTail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(minTail, <span class="hljs-number">0x3f3f3f3f</span>); <span class="hljs-comment">// 便于min比较得出最小索引</span><br>    <span class="hljs-comment">// 遍历list</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 记t为list[i]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> list.get(i);<br>        <span class="hljs-comment">// 二分查找minTail[i]&lt;list[i]的最大数字</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = i;   <span class="hljs-comment">// 二分的是minTail的索引(递增子序列的长度)</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (minTail[mid] &lt; t) &#123;<br>                <span class="hljs-comment">// 1.minTail[mid] &lt; t说明mid也可能是正确答案</span><br>                l = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 2.minTail[mid] &gt;= t说明mid不可能是正确答案</span><br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// l == r 此时l为合法f[j]的最大长度,拼接上list[i]就是l+1</span><br>        f[i] = l + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 更新max</span><br>        max = Math.max(max, f[i]);<br>        <span class="hljs-comment">// 根据当前结尾数字更新minTail(记得是t,因为自始至终比较的是序列结尾数字t)</span><br>        minTail[f[i]] = Math.min(minTail[f[i]], t);<br>    &#125;<br>    <span class="hljs-comment">// 最少要插入的次数=target长度-最长递增子序列长度max</span><br>    <span class="hljs-keyword">return</span> m - max;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>模板1：基于</strong><a href="https://leetcode.cn/problems/longest-increasing-subsequence/"><strong>300. 最长递增子序列</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    根据 1713. 得到子序列的最少操作次数</span><br><span class="hljs-comment">    这里给出一种时间复杂度为O(NlogN)的dp+贪心+二分解法</span><br><span class="hljs-comment">    1 &lt;= nums.length &lt;= 2500</span><br><span class="hljs-comment">    -1e4 &lt;= nums[i] &lt;= 1e4</span><br><span class="hljs-comment">    定义minTail[len]为当前遍历到的长度为len的递增子序列的最小结尾数字</span><br><span class="hljs-comment">    可知minTail[i]必定是单增的,我们可以用二分寻找到f[i]之前一个能拼接的最长的f[j]</span><br><span class="hljs-comment">    最后维护最大的f[i]就是答案</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, max = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span>[] minTail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(minTail, <span class="hljs-number">0x3f3f3f3f</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = i;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (minTail[mid] &lt; nums[i]) &#123;<br>                l = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> l + <span class="hljs-number">1</span>;<br>        max = Math.max(max, cur);<br>        minTail[cur] = Math.min(minTail[cur], nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>模板2：（效率更高）基于</strong><a href="https://leetcode.cn/problems/russian-doll-envelopes/"><strong>354. 俄罗斯套娃信封问题</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] envelopes)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    排序+序列DP+贪心:</span><br><span class="hljs-comment">    1 &lt;= envelopes.length &lt;= 1e5</span><br><span class="hljs-comment">    envelopes[i].length == 2</span><br><span class="hljs-comment">    1 &lt;= wi, hi &lt;= 105</span><br><span class="hljs-comment">    注意到数量范围:我们只能用O(N)或者O(logN)的方法进行解决</span><br><span class="hljs-comment">    1.首先对envelopes按照第一维度升序,第二维度降序进行排序</span><br><span class="hljs-comment">    2.然后我们找到第二维度的严格上升序列的最大长度就是答案</span><br><span class="hljs-comment">    证明:因为这样在第二维度取到的严格上升序列必定不是在第一维度相等的</span><br><span class="hljs-comment">    局部最优的贪心思路:顺序遍历num=envelopes[i][1]</span><br><span class="hljs-comment">    1.当遇到&gt;结尾元素时,直接加入结尾</span><br><span class="hljs-comment">    2.当遇到&lt;=结尾元素时,查找首个&gt;=num的坑位用num取代</span><br><span class="hljs-comment">    总体时间复杂度:O(NlogN) 空间负复杂度:O(N</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> envelopes.length;<br>    Arrays.sort(envelopes, (a, b) -&gt; a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>] : a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// tails[i]表示以长度为i+1的结尾最小数字(必定递增)</span><br>    <span class="hljs-type">int</span>[] tails = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    tails[<span class="hljs-number">0</span>] = envelopes[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// tails结尾索引指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// num大于结尾元素 -&gt; 直接加入并偏移end指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> envelopes[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (num &gt; tails[end]) &#123;<br>            tails[++end] = num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 二分查找适合的插入位置(即寻找首个&gt;=num的坑位)</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = end;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (tails[mid] &lt; num) &#123; <span class="hljs-comment">// 注意是对坑位索引进行二分查找</span><br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// l == r</span><br>            tails[l] = num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// end最后表示最长递增子序列的索引,end+1就是长度(所求)</span><br>    <span class="hljs-keyword">return</span> end + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LIS的O(NlogN)解法压缩至求3元递增子序列</strong></p><p><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/"><strong>334. 递增的三元子序列</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">increasingTriplet</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        LIS问题拓展(贪心)：</span><br><span class="hljs-comment">        我们知道求解LIS问题除了有O(N^2)的方法外，还有一种可以加速至O(NlogN)的方法</span><br><span class="hljs-comment">        利用辅助数组minNum，其中minNum[len]为长度为len的递增子序列结尾最小数字</span><br><span class="hljs-comment">        但是我们这里是求3元子序列，只需要维护最长递增子序列最前面两个即可，因此可以直接在O(1)时间内找到前面可以拼接的数字</span><br><span class="hljs-comment">        时间复杂度:O(N) 空间复杂度:O(1)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// first为长度为1的递增子序列最小结尾数字，second为长度为1的递增子序列最小结尾数字</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, second = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt; second) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// num可以拼接在原来的second后说明已经找到3元递增子序列</span><br>            <span class="hljs-comment">// 维护first与second的值</span><br>            <span class="hljs-keyword">if</span> (num &lt; first) &#123;<br>                first = num;    <span class="hljs-comment">// 1.num最小，必然长度为1最小的就是num</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first &lt; num &amp;&amp; num &lt; second) &#123;<br>                second = num;   <span class="hljs-comment">// 2.first &lt; num说明num可以拼接在first后，再加上nums&lt;second说明最小数字这个位置num可以取代原来的second</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后都找不到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-最长公共子序列（LCS问题）">2.最长公共子序列（LCS问题）</h3><p>最常规的DP转移方程就不说了，我们由此引出常见的问题模型：<strong>判断是否s1是否为s2子串</strong></p><p><strong>方法1：双指针-&gt;O(max(m,n))</strong></p><p>写法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断s1是否为s2子序列,是则返回true</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-comment">// 双指针实现</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s1.length(), len2 = s2.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// p1主动移动且每次移动1格,p2被动移动</span><br>    <span class="hljs-keyword">while</span> (p1 &lt;= len1 - <span class="hljs-number">1</span> &amp;&amp; p2 &lt;= len2 - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// p2被动移动至与s1[p1]==s2[p2]的位置</span><br>        <span class="hljs-keyword">while</span> (p2 &lt;= len2 - <span class="hljs-number">1</span> &amp;&amp; s1.charAt(p1) != s2.charAt(p2)) &#123;<br>            p2++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p2 == len2) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// p2提前结束了就直接结束不要移动p1</span><br>        <span class="hljs-comment">// 共同后移</span><br>        p1++;<br>        p2++;<br>    &#125;<br>    <span class="hljs-comment">// 退出的位置为s1最后一个待匹配的位置,p1指针刚好移出就表明s1是s2子串</span><br>    <span class="hljs-keyword">return</span> p1 == len1;<br>&#125;<br></code></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断s1是否为s2子序列</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s1.length(), len2 = s2.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123;<br>        <span class="hljs-comment">// s2[p2]一直寻找直至与s1[p1]匹配</span><br>        <span class="hljs-keyword">while</span> (p2 &lt; len2 &amp;&amp; s2.charAt(p2) != s1.charAt(p1)) p2++;<br>        <span class="hljs-keyword">if</span> (p2 &lt; len2) &#123;<br>            <span class="hljs-comment">// p1每次主动移动一位(p2匹配上了才移动)</span><br>            p1++;<br>            <span class="hljs-comment">// p2也要移动</span><br>            p2++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1 == len1;  <span class="hljs-comment">// p1==len1说明p1最后一位也匹配到p2有效值，p1==len1退出，说明s1是s2子串</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法2：DP-&gt;O(m*n)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最长公共子序列方法求解(LCS问题)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s1.length(), len2 = s2.length();<br>    <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];    <span class="hljs-comment">// f[i][j]表示考虑s1[0,i-1]与s2[0,j-1]最长公共子序列长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>            <span class="hljs-comment">// 考虑s1[i - 1]与s2[j - 1]是否相等来分类转移</span><br>            <span class="hljs-keyword">if</span> (s1.charAt(i - <span class="hljs-number">1</span>) == s2.charAt(j - <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 1.相等直接转移</span><br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 2.不相等其中有一个必定不能取,但是另外一个可能可以</span><br>                f[i][j] = Math.max(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[len1][len2] == len1;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 序列DP </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于基环树、拓扑排序和时间戳的总结</title>
      <link href="/%E5%85%B3%E4%BA%8E%E5%9F%BA%E7%8E%AF%E6%A0%91%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E6%80%BB%E7%BB%93.html"/>
      <url>/%E5%85%B3%E4%BA%8E%E5%9F%BA%E7%8E%AF%E6%A0%91%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p><strong>基环树定义可以参考：</strong><a href="https://blog.csdn.net/weixin_45697774/article/details/108948457">【算法笔记】基环树</a></p><p><a href="https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/"><strong>6134. 找到离给定两个节点最近的节点</strong></a></p><p>这题是求<strong>点到点</strong>之间距离的问题，要点是一直循环记录就可以，退出条件为检测到成环了或者走到尽头</p><p>由于每个节点 至多 有一条出边，因此变成了一条没有分叉的路，BFS或者DFS都是可以的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestMeetingNode</span><span class="hljs-params">(<span class="hljs-type">int</span>[] edges, <span class="hljs-type">int</span> node1, <span class="hljs-type">int</span> node2)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    基环树问题：</span><br><span class="hljs-comment">    直接预处理出node1以及node2到其他所有点的距离</span><br><span class="hljs-comment">    然后枚举每个节点，求出两者最大距离的最小时对应的节点索引返回</span><br><span class="hljs-comment">    时间复杂度:O(N) 空间复杂度:O(N)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> edges.length;<br>    <span class="hljs-comment">// dis1[i]存储node1到节点编号为i的节点距离，dis2[i]存储node2到节点编号为i的节点距离(不能到达为-1)</span><br>    <span class="hljs-type">int</span>[] dis1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], dis2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Arrays.fill(dis1, -<span class="hljs-number">1</span>);<br>    dis1[node1] = <span class="hljs-number">0</span>;<br>    Arrays.fill(dis2, -<span class="hljs-number">1</span>);<br>    dis2[node2] = <span class="hljs-number">0</span>;<br>    getDis(edges, node1, dis1);<br>    getDis(edges, node2, dis2);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;   <span class="hljs-comment">// 结果</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (dis1[i] == -<span class="hljs-number">1</span> || dis2[i] == -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 只有两个都可以到达才进行统计</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curMax</span> <span class="hljs-operator">=</span> Math.max(dis1[i], dis2[i]);<br>        <span class="hljs-keyword">if</span> (curMax &lt; min)&#123;<br>            min = curMax;<br>            res = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 获取node到节点i的距离并写入dis[i]</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDis</span><span class="hljs-params">(<span class="hljs-type">int</span>[] edges, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span>[] dis)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> node, d = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 当有可以前往的节点，继续走</span><br>    <span class="hljs-keyword">while</span> (edges[cur] != -<span class="hljs-number">1</span>) &#123;<br>        cur = edges[cur];   <span class="hljs-comment">// 走到下一个节点</span><br>        d++;<br>        <span class="hljs-keyword">if</span> (dis[cur] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 成环访问到同一个节点了，退出</span><br>        dis[cur] = d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-cycle-in-a-graph/"><strong>6135. 图中的最长环</strong></a></p><p>这题也是基环树，因为出边限定了一条，但是可能有多个环</p><p>DFS时间戳一般是 times[i] 的形式，times[i] 记录的是首次访问节点 i 的时间节点</p><p>通过时间戳我们可以很轻易地得知该轮<strong>之前已经访问过了哪些节点</strong>并计算出距离</p><p>同时得知<strong>之前轮已经访问过的点</strong>，是一个兼具标记访问、标记先后顺序、标记距离、前缀和等参数的利器</p><p>可以用来<strong>判断是否成环、判断节点的父子关系</strong>等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] edges)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        基环树+时间戳</span><br><span class="hljs-comment">        times[i]记录首次访问编号为i的节点时间点，clock维护当前的时间节点</span><br><span class="hljs-comment">        我们枚举每个出发点</span><br><span class="hljs-comment">        1.遇到之前访问过的节点times[i]&gt;0，跳过</span><br><span class="hljs-comment">        2.首次访问节点i，从节点i出发向前走同时标记访问过的节点的时间戳</span><br><span class="hljs-comment">        如果前方出现过times[j]&gt;0的情况说明这个时候节点已经被访问过，说明成环了</span><br><span class="hljs-comment">        注意:为了避免后面枚举的节点重复经过之前访问过的节点但是不成环的情况，要加一个判断条件times[j]&gt;=start</span><br><span class="hljs-comment">        其中start为从i点出发的时间戳，若成环必然有times[j]&gt;=start，重复经过旧节点但是不成环的情况是times[j]&lt;start</span><br><span class="hljs-comment">        因为你这个times[j]之前一轮出发点中已经枚举过了，时间必定在该轮start之前</span><br><span class="hljs-comment">        维护这个环的长度最大值就是答案</span><br><span class="hljs-comment">        时间复杂度:O(N) 空间复杂度:O(N)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> edges.length;<br>        <span class="hljs-type">int</span>[] times = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 枚举每个出发点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, clock = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (times[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 这个出发点已经访问过了，跳过</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> clock;  <span class="hljs-comment">// start维护当前出发点的出发时间</span><br>            <span class="hljs-comment">// 枚举以节点i为出发点的路径上的点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i; x != -<span class="hljs-number">1</span>; x = edges[x]) &#123;<br>                <span class="hljs-keyword">if</span> (times[x] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 已经访问过该节点(不一定是该轮的)</span><br>                    <span class="hljs-comment">// 若该节点是该轮才访问的说明成环了</span><br>                    <span class="hljs-keyword">if</span>(times[x] &gt;= start) res = Math.max(res, clock - times[x]);  <span class="hljs-comment">// 维护最大环值</span><br>                    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 已经访问过节点就退出，不论是该轮访问的还是之前</span><br>                &#125;<br>                times[x] = clock++; <span class="hljs-comment">// 标记访问该节点的最早时间戳</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/"><strong>2322. 从树中删除边的最小分数</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] nums, xr, in, out; <span class="hljs-comment">// xr[i]为以i为根的子树异或和,in和out分别是节点i dfs递归进栈和出栈的时间点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">clock</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 全局时间戳(以0为根的dfs序)</span><br>    List&lt;Integer&gt;[] list;   <span class="hljs-comment">// 存边</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] _nums, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        DFS时间戳+枚举新树根节点+异或性质运用:</span><br><span class="hljs-comment">        题目是将整棵树切成3部分,我们就假设0为树原来的根节点(确定根节点方便求异或),切割之后另外两棵子树根节点为x与y</span><br><span class="hljs-comment">        假设x是y的根节点,由于枚举的是不同的点,因此不存在互相包含的情况</span><br><span class="hljs-comment">        此时有:in[x]&lt;in[y]&lt;=out[y]&lt;=out[x] 其中in[y]&lt;=out[y]必定成立,因此x是y的根节点等价于in[x]&lt;in[y]&amp;&amp;out[y]&lt;=out[x]</span><br><span class="hljs-comment">        利用时间戳的可以用来快速判断x与y节点之间的父子关系(以0为原始根节点)</span><br><span class="hljs-comment">        我们枚举删除边后产生的两个新的根节点,设a,b,c分别为0,x,y为根的切断后子树异或和,有以下3种情况:</span><br><span class="hljs-comment">        1.x是y的根节点且位于初始根节点0的同侧-&gt;异或和分别为:c=xr[y],b=xr[x]^xr[y],a=xr[0]^xr[x]</span><br><span class="hljs-comment">        2.y是x的根节点且位于初始根节点0的同侧-&gt;异或和分别为:b=xr[x],c=xr[y]^xr[x],a=xr[0]^xr[y]</span><br><span class="hljs-comment">        3.y与x分局初始根节点0的异侧-&gt;异或和分别为:c=xr[y],b=xr[x],a=xr[0]^xr[x]^xr[y]</span><br><span class="hljs-comment">        分别枚举x∈[1,n],y∈[x+1,n],维护异或和差值的最小值</span><br><span class="hljs-comment">         */</span><br>        nums = _nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>, n = nums.length;<br>        xr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            list[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], b = e[<span class="hljs-number">1</span>];<br>            list[a].add(b);<br>            list[b].add(a);<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化各个节点时间戳以及求每个节点为根的异或和</span><br>        <span class="hljs-comment">// 枚举删除边后产生的两个新的根节点x与y</span><br>        <span class="hljs-type">int</span> a, b, c;    <span class="hljs-comment">// 设a,b,c分别为0,x,y为根切断后子树的异或和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; x &lt; n; x++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x + <span class="hljs-number">1</span>; y &lt; n; y++) &#123;<br>                <span class="hljs-keyword">if</span> (isParent(x, y)) &#123;   <span class="hljs-comment">// x是y根节点</span><br>                    a = xr[<span class="hljs-number">0</span>] ^ xr[x];<br>                    b = xr[x] ^ xr[y];<br>                    c = xr[y];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isParent(y, x)) &#123;    <span class="hljs-comment">// y是x根节点</span><br>                    a = xr[<span class="hljs-number">0</span>] ^ xr[y];<br>                    b = xr[x];<br>                    c = xr[y] ^ xr[x];<br>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// x与y分布异侧</span><br>                    a = xr[<span class="hljs-number">0</span>] ^ xr[x] ^ xr[y];<br>                    b = xr[x];<br>                    c = xr[y];<br>                &#125;<br>                <span class="hljs-comment">// 维护异或和最大差值的最小值</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(a, Math.max(b, c)), min = Math.min(a, Math.min(b, c));<br>                res = Math.min(res, max - min);<br>                <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 为0提前退出</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断x是否为y的父节点(不重合)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isParent</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> in[x] &lt; in[y] &amp;&amp; out[y] &lt;= out[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 求节点时间戳和异或和:其中i为当前节点索引,fa为其父节点(用于避免走回头路)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> fa)</span> &#123;<br>        xr[i] = nums[i];    <span class="hljs-comment">// xr[i]初始化为节点i的值</span><br>        in[i] = ++clock;    <span class="hljs-comment">// 记录进入的时间戳</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : list[i]) &#123;<br>            <span class="hljs-keyword">if</span> (next != fa) &#123;   <span class="hljs-comment">// 不走回头路</span><br>                dfs(next, i);   <span class="hljs-comment">// 求出以next为根的异或和与时间戳</span><br>                xr[i] ^= xr[next];  <span class="hljs-comment">// xr[i]添上xr[next]</span><br>            &#125;<br>        &#125;<br>        out[i] = clock; <span class="hljs-comment">// 记录i出栈时间戳</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拓扑排序检测环的应用</strong></p><p>拓扑排序可以<strong>将不在环中的节点先全部删除掉</strong>然后就会剩下只在环中的节点</p><p>可以统计删除的节点数目对比总节点的数目就可以得知是否存在环</p><p>环中的节点个数可以直接通过for循环遍历进行统计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] edges)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    基环树+拓扑排序</span><br><span class="hljs-comment">    拓扑排序可以优先逐步筛选掉那些入度为0的节点，最后就只剩下成环的节点了</span><br><span class="hljs-comment">    拓扑排序总体思路为:</span><br><span class="hljs-comment">    1.定义入度数组并统计每个节点的入度，首次先将入度为0点节点入队</span><br><span class="hljs-comment">    2.将上一轮的入队的节点的弹出删除，并将出队节点指向的节点入度-1，如果此时又有节点入度为0就入队，以此类推直至队列为空</span><br><span class="hljs-comment">    (注意上述过程入队的节点都要进行标记后面不能再用)</span><br><span class="hljs-comment">    3.剩下的节点就是成环的，入度永远也不可能为0的节点了</span><br><span class="hljs-comment">        这里可以提前判断一下剩余节点个数是不是为0了，如果是可以提前退出</span><br><span class="hljs-comment">    4.枚举每个节点进行for循环遍历(因为只有一条出边因此可以用for循环代替DFS/BFS)</span><br><span class="hljs-comment">        如果已经删除掉的就跳过，如果不是就证明这个节点必然在环中，直接for循环遍历并统计最大长度</span><br><span class="hljs-comment">        遍历过的环同样进行标记避免下一次重复访问</span><br><span class="hljs-comment">        那么最后统计到的最大长度就是最长环</span><br><span class="hljs-comment">    时间复杂度:O(N) 空间复杂度:O(N)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> edges.length;<br>    <span class="hljs-type">boolean</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>    Queue&lt;Integer&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();    <span class="hljs-comment">// 辅助队列</span><br>    <span class="hljs-type">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];    <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : edges) &#123;<br>        <span class="hljs-keyword">if</span> (e != -<span class="hljs-number">1</span>) inDegree[e]++;<br>    &#125;<br>    <span class="hljs-comment">// 入度为0的节点优先入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            que.add(i);<br>            vis[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记访问</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> que.poll();  <span class="hljs-comment">// 删除节点poll</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> edges[poll]; <span class="hljs-comment">// 指向的节点索引</span><br>        <span class="hljs-comment">// 注意可能不成环的情况next在最后一个节点为-1，因此要加一个判断</span><br>        <span class="hljs-keyword">if</span> (next != -<span class="hljs-number">1</span> &amp;&amp; --inDegree[next] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 由于删除了节点poll因此其指向的节点对应入度也-1，若为0就入队</span><br>            que.add(next);<br>            vis[next] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 剩下的节点就是环上的节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 访问过的节点跳过</span><br>        <span class="hljs-comment">// 否则就是未访问过的环上的节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> i, cycleNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!vis[edges[cur]]) &#123;<br>            cur = edges[cur];<br>            cycleNum++;<br>            vis[cur] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        res = Math.max(res, cycleNum);  <span class="hljs-comment">// 维护环的最大值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> 时间戳 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法</title>
      <link href="/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html"/>
      <url>/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Dijkstra算法（优先用堆优化实现方式）">1.Dijkstra算法（优先用堆优化实现方式）</h3><p><strong>主要步骤：</strong></p><p>1.每次从<strong>未标记的节点</strong>中选择<strong>距离出发点最近</strong>的节点，标记，收录到最优路径集合中。</p><p>⒉计算刚加入节点A的邻近节点B的距离（不包含标记的节点)</p><p>若 <strong>（节点A的距离+节点A到节点B的边长)&lt;节点B的距离</strong> ，就<strong>更新节点B的距离和前面点</strong>。</p><p>本质是<strong>贪心算法</strong>：我现在就把出发点到B的已知的最短距离摆在这里，下次如果你要从出发点起出发路过B然后到达C，且B到C仅有一条路径，距离是固定的，因此必定是用先前求出来的出发点到B的最短距离来进行求解，这是出发点经过B到C的最短路径；当然，走到C可不止经过B这一种路径，还可能经过X到达C，那么我开门这时候就可以维护出发点到达C的最短路，到时候这个到达C的最短路又可以用了；以此类推直至到达终点。</p><p>注意：Dijkstra算法只适用于权重为非负数的带权图！<br><img src="../images/p4.jpg" alt="p4"></p><p>或者和BFS进行类比，BFS是每次走1步，如果当路径很长时显然不现实；</p><p>因此，Dijkstra算法每次迭代是以节点作为单元，通常为了节省时间我们会用<strong>堆（TreeSet?）</strong> 来优化</p><p>总的时间复杂度为:O(NlogN) 空间复杂度:O(N)  其中N为边数</p><p><img src="../images/p5.jpg" alt="p5"></p><p>以上图为例，从节点0开始出发，从现在起只向前走，0已经被标记了不会再走回头路，marked=[0]；</p><p>节点[4,5] [6,7] [1,2] 入队，接下来先弹出距离起点最短的节点1([1,2])（为啥可以这么快弹出来？因为可以确定出发点0到节点1最短距离就是2，其他节点要想走到节点1只能从4和6走，又由于<strong>没有负边权</strong>其他路肯定更长，因此出发点到节点1的最短距离就是2）</p><p><strong>节点弹出就意味着起点到弹出的节点最短距离已经确定了，此时可以标记掉节点1下次不用再走回头路，marked=[0,1]</strong></p><p>节点1下面有节点2和3，此时计算后为[2,5] [3,5]入队；此时队列中元素为 que= [[4,5] [6,7] [2,5] [3,5]]</p><p>又进入下一轮的筛选，到起点距离最短的节点有3个，距离都为5</p><p>假如弹出节点4，那么[6,7]就会入队  此时队列为 que=[[6,7] [6,7] [2,5] [3,5]] marked=[0,1,4]</p><p>接下来弹出[2,5] 加入[5,6]    此时队列为 que=[[6,7] [6,7] [5,6] [3,5]] marked=[0,1,2,4]</p><p>弹出[3,5] 加入[5,6]  此时队列为 que=[[6,7] [6,7] [5,6] [5,6]] marked=[0,1,2,3,4]</p><p>弹出[5,6] 加入[6,7]  此时队列为 que=[[6,7] [6,7] [6,7] [5,6]] marked=[0,1,2,3,4,5]</p><p>弹出[5,6] 加入[6,7]  此时队列为 que=[[6,7] [6,7] [6,7] [6,7]] marked=[0,1,2,3,4,5]</p><p>弹出[6,7] 标记节点6  que=[[6,7] [6,7] [6,7]] marked=[0,1,2,3,4,5,6]</p><p>至此，搜索完毕，此时的节点0到节点6最短距离为7</p><p><strong>关于 Dijkstra算法节点标记访问的问题：</strong></p><p>1.如果是边权只有0与正数的，可以在入队时候直接标记，因为到时候兜回来肯定比现在的长（提高性能）；</p><p>2.如果边权不是上述情况，只能在弹出的时候标记访问，只有在弹出时才可以确定起点到该点的最短路径。</p><p><img src="../images/p6.jpg" alt="p6"><br><img src="../images/p7.jpg" alt="p7"></p><p>参考：</p><p><strong>1.Dijkstra图解动画：</strong><a href="https://www.bilibili.com/video/BV1zz4y1m7Nq">【算法】最短路径查找—Dijkstra算法_哔哩哔哩_bilibili</a></p><p><strong>2.三叶姐的最短路径模板(背下来)</strong>：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247488007&amp;idx=1&amp;sn=9d0dcfdf475168d26a5a4bd6fcd3505d&amp;chksm=fd9cb918caeb300e1c8844583db5c5318a89e60d8d552747ff8c2256910d32acd9013c93058f&amp;token=211780171&amp;lang=zh_CN#rd">三叶姐最短路模板</a></p><p><strong>3.自己写的答案与例题：</strong><a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a></p><p><strong>4.矩阵型Dijkstra参考：</strong></p><p><a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event/">675. 为高尔夫比赛砍树</a></p><p><a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">2290. 到达角落需要移除障碍物的最小数目</a></p><p><a href="https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/">1368. 使网格图至少有一条有效路径的最小代价</a></p><p><strong>标准模板（矩阵型的图可以将二维(x,y)坐标压缩成一维m*x+y）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        最短路算法:</span><br><span class="hljs-comment">        我们先别被箭头迷惑了，先把所有路都当做可以走，不过要走到下一个节点的代价增加了而已</span><br><span class="hljs-comment">        看到了这一点那么这题就可以转化为最短路径的题目</span><br><span class="hljs-comment">        网格中某个点grid[i][j]每次可以往上下左右走一格</span><br><span class="hljs-comment">        1.如果走的方向与原来的方向不一致则消耗一次改格子的次数，cost++</span><br><span class="hljs-comment">        2.如果走的方向与原来的方向一致则不消耗次数，cost不变</span><br><span class="hljs-comment">        求到达grid[m-1][n-1]消耗的最少次数（最小代价、最短路径）</span><br><span class="hljs-comment">        因为代价只有0和1两种，因此既可以用Dijkstra算法，又可以用01BFS</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 解法1:Dijkstra算法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-type">int</span>[][] cost = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            Arrays.fill(cost[i], INF);<br>        &#125;<br>        cost[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 根据到起点的最短距离升序(注意最好不要根据cost直接排序，因为cost会随时改变，弹出时会有出错风险)</span><br>        <span class="hljs-comment">// 也就是说你的cost改变了后，pq里面放在头部的元素可能还未来得及改变，因此最好的比较的变量独立且不会被修改</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="hljs-number">0</span>]));<br>        pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] p = pq.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">1</span>], y = p[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (vis[x][y]) <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">// 访问过就跳过</span><br>            vis[x][y] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 当且仅当弹出才能确定起点到达改点的最小代价，标记为true</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + dirs[i][<span class="hljs-number">0</span>], ny = y + dirs[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 在区域内才需要计算，这里不用保证未访问过，因为前面的路是新的</span><br>                <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n) &#123;<br>                    <span class="hljs-comment">// 只有方向对才不用付出代价，否则要付出代价</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span> == grid[x][y] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">// nc为起点经过grid[x][y]到达grid[nx][ny]的最小代价</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nc</span> <span class="hljs-operator">=</span> cost[x][y] + g;<br>                    <span class="hljs-comment">// 小于原来的cost[nx][ny]就可以更新并入队</span><br>                    <span class="hljs-keyword">if</span> (nc &lt; cost[nx][ny]) &#123;<br>                        cost[nx][ny] = nc;<br>                        pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nc, nx, ny&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cost[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>自定义比较规则时候的一些细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a -&gt; cost[a[<span class="hljs-number">0</span>]][a[<span class="hljs-number">1</span>]));<br>                                                                                       <br><span class="hljs-comment">//根据到起点的最短距离升序(注意最好不要根据cost直接排序，因为cost会随时改变，弹出时会有出错风险)</span><br><span class="hljs-comment">//也就是说你的cost改变了后，pq里面放在头部的元素可能还未来得及改变，因此最好的比较的变量独立且不会被修改 </span><br>PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a -&gt; a[O]));<br></code></pre></td></tr></table></figure><h3 id="2-01BFS">2.<strong>01BFS</strong></h3><p><a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/"><strong>2290. 到达角落需要移除障碍物的最小数目</strong></a></p><p><a href="https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/"><strong>1368. 使网格图至少有一条有效路径的最小代价</strong></a></p><p>我们都知道BFS是一种最基础的最短路径算法，因为队列保证了距离的二段性，先出队的距离必定小于等于后出队的距离，因此必定会以最短的路径找到终点，类似于洪水均匀蔓延的思想。</p><p>此算法是Dijkstra等求最短路的优秀替代</p><p>适用于求最短路径，但是有个要求：<strong>边权为0和1(或0和其他正数）</strong>。</p><p>求最短路的时间复杂度可以由 O(mlogn) 降到 O(m)！(n为点的个数，m为边的个数）</p><p>原理：这是 dijkstra 的优化，若边权只是 0 和 1 ，启用优先队列未免太浪费资源了！</p><p>用双端队列正是对这个地方的优化，将优先队列插入元素 O(logn) 的时间复杂度降到了 O(1)！！</p><p><strong>过程：</strong></p><p>从起点开始，加入队列。</p><p>while队列非空，取队首元素，用这个节点更新其他节点。</p><p>如果可以更新的话：</p><p>1、边权为0，放到队首。（从边权为0的边走，不增加消耗，得多走这样的边）</p><p>2、边权为其他，放到队尾。（增加消耗，少用）</p><p>（这样，队列前面的元素值一定比后面的元素值小（可以手动模拟下），每次求队首元素来更新相连的点的距离，完美的替代了优先队列的功能！）</p><p><strong>因为将权重为0的节点加入进来不会使得当前最大距离变大，最短路径树还是处于同一层，相当于将等距线最大限度地蔓延到更远的地方。</strong></p><p>参考：<a href="https://blog.csdn.net/Mr_dimple/article/details/116864052">双端队列_01bfs——附详解典例</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        01BFS解法：</span><br><span class="hljs-comment">        本题相当于求从grid[0,0]到grid[m-1][n-1]的最短路径(最低成本)，其中经过障碍物成本为1，空地成本为0</span><br><span class="hljs-comment">        用常规的堆优化Dijkstra解法时间复杂度为O(m*n*log(m*n))</span><br><span class="hljs-comment">        利用01BFS可以将时间复杂度降为O(m*n)，也就是说每个节点只入队1次，不会重复访问且可以在O(1)内找到最短距离的节点</span><br><span class="hljs-comment">        过程为：用一个双端队列维护入队元素，然后如果下一个格子为0可以进入队头，否则进入队尾</span><br><span class="hljs-comment">            同时利用一个dis二维数组维护起点蔓延到该点的最短距离，最后返回dis[m-1][n-1]就是所求</span><br><span class="hljs-comment">        时间复杂度:O(m*n) 空间复杂度:O(m*n)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span>[][] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];    <span class="hljs-comment">// dis[i][j]维护起点蔓延到grid[i][j]时的最短距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            Arrays.fill(dis[i], INF);<br>        &#125;<br>        dis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起点到起点的距离为0</span><br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] p = que.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">0</span>], y = p[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] d : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + d[<span class="hljs-number">0</span>], ny = y + d[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nd</span> <span class="hljs-operator">=</span> dis[x][y] + grid[nx][ny];<br>                    <span class="hljs-keyword">if</span> (nd &lt; dis[nx][ny]) &#123;<br>                        dis[nx][ny] = nd;   <span class="hljs-comment">// dis[nx][ny]继承小的值</span><br>                        <span class="hljs-comment">// 看当前格子为0就入队头，否则入队尾</span><br>                        <span class="hljs-keyword">if</span> (grid[nx][ny] == <span class="hljs-number">0</span>) &#123;<br>                            que.addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nx, ny&#125;);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            que.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nx, ny&#125;);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dis[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    最短路径算法:</span><br><span class="hljs-comment">    我们先别被箭头迷惑了，先把所有路都当做可以走，不过要走到下一个节点的代价增加了而已</span><br><span class="hljs-comment">    看到了这一点那么这题就可以转化为最短路径的题目</span><br><span class="hljs-comment">    网格中某个点grid[i][j]每次可以往上下左右走一格</span><br><span class="hljs-comment">    1.如果走的方向与原来的方向不一致则消耗一次改格子的次数，cost++</span><br><span class="hljs-comment">    2.如果走的方向与原来的方向一致则不消耗次数，cost不变</span><br><span class="hljs-comment">    求到达grid[m-1][n-1]消耗的最少次数（最小代价、最短路径）</span><br><span class="hljs-comment">    因为代价只有0和1两种，因此既可以用Dijkstra算法，又可以用01BFS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 解法2:01BFS</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-type">int</span>[] dx = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, dy = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span>[][] cost = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        Arrays.fill(cost[i], INF);<br>    &#125;<br>    cost[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    Deque&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    que.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>        <span class="hljs-type">int</span>[] p = que.pollFirst();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">0</span>], y = p[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + dx[i], ny = y + dy[i];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n) &#123;<br>                <span class="hljs-comment">// 只有方向对才不用付出代价，否则要付出代价</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span> == grid[x][y] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// nc为起点经过grid[x][y]到达grid[nx][ny]的最小代价</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">nc</span> <span class="hljs-operator">=</span> cost[x][y] + g;<br>                <span class="hljs-comment">// 小于原来的cost[nx][ny]就可以更新并入队</span><br>                <span class="hljs-keyword">if</span> (nc &lt; cost[nx][ny]) &#123;<br>                    cost[nx][ny] = nc;<br>                    <span class="hljs-comment">// 重点</span><br>                    <span class="hljs-keyword">if</span> (g == <span class="hljs-number">0</span>) &#123;<br>                        que.addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nx, ny&#125;);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        que.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nx, ny&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cost[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-AStar算法（启发式搜索）">3.AStar算法（启发式搜索）</h3><p><strong>待续…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码模板</title>
      <link href="/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF.html"/>
      <url>/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Java快读模板">1.Java快读模板</h3><p>我们以往使用的<code>Scanner sc = new Scanner(System.in);</code>和<code>String s = sc.nextLine();</code>在输入数据非常大的时候会变得很慢，增加程序运行时间，因此用字符缓冲流来代替，提高运行速度!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Input_Output</span> &#123;<br>    <span class="hljs-comment">// 缓冲输入流</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>    <span class="hljs-comment">// 输出流</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">Line</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            p = bf.readLine();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO 自动生成的 catch 块</span><br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">inStr</span> <span class="hljs-operator">=</span> Line();<br>        pw.println(inStr);<br>        pw.flush();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-二叉树处理模板">2.二叉树处理模板</h3><p>二叉树是最常见的数据结构之一，在处理输入的通常是一个数组要转化为二叉树，而输出的时候往往要将二叉树转化为数组。</p><p>下面是<strong>二叉树节点类+根据int类型数组生成二叉树+给定root打印二叉树值</strong>的代码模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.Binary_Trees;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Fomalhaut</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/4/26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 二叉树工具类:序列化与反序列化(不带多余null)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeUtils</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化二叉树</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 根节点引用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> String 序列化后以字符串形式表示的二叉树序列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;<br>        &#125;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.add(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 1.node不为空的情况</span><br>                <span class="hljs-comment">// node的值加入sb(自动转型)</span><br>                list.add(node.val + <span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-comment">// 左右子节点无论是否为空照样入队</span><br>                que.add(node.left);<br>                que.add(node.right);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 2.node为空的情况</span><br>                <span class="hljs-comment">// &quot;null&quot;这个字符串加入sb即可</span><br>                list.add(<span class="hljs-string">&quot;null&quot;</span>);<br>                <span class="hljs-comment">// 空节点没有左右子节点了</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;null&quot;</span>.equals(list.get(i))) &#123;<br>                flag = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;[&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= flag; i++) &#123;<br>            sb.append(list.get(i)).append(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;]&quot;</span>).toString();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化二叉树</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 二叉树字符串序列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> TreeNode 反序列化后二叉树根节点引用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;[]&quot;</span>.equals(data)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 首先将字符串转化为每个值的字符串数组(去头尾+&quot;,&quot;分割)</span><br>        String[] strs = data.substring(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">1</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">strsLen</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-comment">// 遍历序列化数据的索引(初始化为1指向root左子节点)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 辅助队列</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 创建根节点</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(strs[<span class="hljs-number">0</span>]));<br>        <span class="hljs-comment">// 根节点入队</span><br>        que.add(root);<br>        <span class="hljs-comment">// 开启遍历</span><br>        <span class="hljs-keyword">while</span>(!que.isEmpty()) &#123;<br>            <span class="hljs-comment">// 队头节点出队</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-comment">// 只要strs[i](出队节点的某个子节点)不是null就可以参与树的构建</span><br>            <span class="hljs-keyword">if</span>(i &lt; strsLen &amp;&amp; !<span class="hljs-string">&quot;null&quot;</span>.equals(strs[i])) &#123;<br>                <span class="hljs-comment">// 构建新的左子节点并完成指向</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(strs[i]));<br>                node.left = left;<br>                <span class="hljs-comment">// 左子节点入队</span><br>                que.add(left);<br>            &#125;<br>            <span class="hljs-comment">// 索引向右移动</span><br>            i++;<br>            <span class="hljs-keyword">if</span>(i &lt; strsLen &amp;&amp; !<span class="hljs-string">&quot;null&quot;</span>.equals(strs[i])) &#123;<br>                <span class="hljs-comment">// 构建新的右子节点并完成指向</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(strs[i]));<br>                node.right = right;<br>                <span class="hljs-comment">// 右子节点入队</span><br>                que.add(right);<br>            &#125;<br>            <span class="hljs-comment">// 索引继续向右移动</span><br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 返回根节点</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-链表处理模板">3.链表处理模板</h3><p>链表是最简单的数据结构之一，下面给出<strong>链表节点类+根据int数组生成链表+给定head打印节点值</strong>代码模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Fomalhaut</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/4/25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 链表工具类:构建+打印</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkListUtil</span> &#123;<br>    <span class="hljs-comment">// 由数组生成链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">generateLinkList</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">nex</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>            cur.next = nex;<br>            nex = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nex;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLinkList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            list.add(cur.val);<br>            cur = cur.next;<br>        &#125;<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Fomalhaut</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/4/25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 节点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br><br>    ListNode() &#123;<br>    &#125;<br><br>    ListNode(<span class="hljs-type">int</span> val) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 输入输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码、反码与补码</title>
      <link href="/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E4%B8%8E%E8%A1%A5%E7%A0%81.html"/>
      <url>/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E4%B8%8E%E8%A1%A5%E7%A0%81.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-原码">1.原码</h3><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制：</p><p><a href="%E5%8E%9F%E7%A0%81">+1</a> = 0000 0001</p><p><a href="%E5%8E%9F%E7%A0%81">-1</a> = 1000 0001</p><p><strong>第一位是符号位</strong>，所以8位二进制数的取值范围就是：</p><p>[1111 1111 , 0111 1111]</p><p>即</p><p>[-127 , 127]</p><p>原码是人脑最容易理解和计算的表示方式。</p><h3 id="2-反码">2.反码</h3><p>反码的表示方法是: 正数的反码是其本身，<strong>负数的反码是在其原码的基础上，符号位不变，其余各个位取反</strong>。</p><p>[+1] = <a href="%E5%8E%9F%E7%A0%81">00000001</a>= <a href="%E5%8F%8D%E7%A0%81">00000001</a></p><p>[-1] = <a href="%E5%8E%9F%E7%A0%81">10000001</a>= <a href="%E5%8F%8D%E7%A0%81">11111110</a></p><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。</p><h3 id="3-补码">3.补码</h3><p>补码的表示方法是：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1 (即在<strong>反码的基础上+1</strong>)。</p><p>[+1] = <a href="%E5%8E%9F%E7%A0%81">00000001</a> = <a href="%E5%8F%8D%E7%A0%81">00000001</a> = <a href="%E8%A1%A5%E7%A0%81">00000001</a></p><p>[-1] = <a href="%E5%8E%9F%E7%A0%81">10000001</a> = <a href="%E5%8F%8D%E7%A0%81">11111110</a> = <a href="%E8%A1%A5%E7%A0%81">11111111</a></p><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。</p><p>补码解决了0的符号以及两个编码的问题，让计算机的减法可以直接转为加法运算(计算机内部都是用<strong>补码</strong>直接运算，只有负数与原码不一致):</p><p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p><p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以<strong>用[1000 0000]表示-128</strong>:</p><p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p><p>-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补就是-128。但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示 。</p><p>使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够：多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。</p><p><strong>计算机利用补码实现两数相减：</strong><br><img src="../images/p3.jpg" alt="p3"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算技巧总结</title>
      <link href="/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93.html"/>
      <url>/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>1.<code>n&amp;(n-1)</code> 将n的<strong>最低位</strong> 1置0。例如:<code>11011000&amp;1010111=11010000</code></p><p>2.获取二进制中<strong>最右边的1</strong>，且其它位置为0: <code>n &amp; (-n)</code> 。例如:<code>n=01011000，-n=11011000(原)=10100111(反)=10101000(补)</code></p><p><code>n&amp;(-n)=01011000&amp;10101000=00001000</code>，相当于提取了最右边的1其余位为0（树状数组会）</p><p>3.任何数和0做异或运算，结果仍然是原来的数，即 <strong><code>a^0=a</code></strong>。 例如:<code>11011000^00000000=11011000</code></p><p>4.任何数和其自身做异或运算，结果是 0，即 <strong><code>a^a=0</code></strong>。例如:<code>11011000^11011000=00000000</code></p><p>5.异或运算满足交换律和结合律，<code>a^b^a=b^a^a=b^(a^a)=b^0=b</code></p><p>6.<strong><code>Integer.numberOfTrailingZeros(int i)</code></strong> 返回指定int值的二进制补码二进制表示形式中最低位1之后的0的数目。</p><p>7.<strong><code>Integer.numberOfLeadingZeros(int i)</code></strong> 返回这个数据的二进制串中从最左边算起连续的“0”的总数量。因为int类型的数据长度为32所以高位不足的地方会以“0”填充。</p><p><code>Integer.numberOfTrailingZeros(10); </code>   // 10=1010(2) -&gt; 输出结果为1(最低位1尾随0个数)  <code>Integer.numberOfLeadingZeros(2);</code>    // 2=10(2) -&gt; 输出结果为30(不足前面补0) // 那么求二级制表示一共有多少位就有一个技巧 <code>32 - Integer.numberOfLeadingZeros(2); </code>   // 返回2</p><p><font size=4><strong>详细参考：</strong></font><a href="https://blog.csdn.net/wat1r/article/details/114298873"><strong><font size=4>位运算操作常见技巧</font></strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题零碎知识点</title>
      <link href="/%E5%88%B7%E9%A2%98%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
      <url>/%E5%88%B7%E9%A2%98%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-String-Join-方法-A-String-B-String">1.String.Join 方法 (A (String), B (String[]))</h3><p>在指定 String 数组B的每个元素之间串联指定的分隔符 A，从而产生单个串联的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String [] tmpStr = &#123;abc, def, ghi&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">jn</span> <span class="hljs-operator">=</span> string.Join(“-“, tmpStr);<span class="hljs-comment">// 此时输出为”abc-def-ghi”</span><br><span class="hljs-comment">// 常见用法:字符串数组chs-&gt;字符串str</span><br>String.join(<span class="hljs-string">&quot;&quot;</span>,strings)<span class="hljs-comment">//&#123;&quot;abcdefghi&quot;&#125;</span><br></code></pre></td></tr></table></figure><br/><h3 id="2-split-根据匹配给定的正则表达式来拆分字符串">2.split() 根据匹配给定的正则表达式来拆分字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Welcome-to-Runoob&quot;</span>;<br><span class="hljs-keyword">for</span> (String retval: str.split(<span class="hljs-string">&quot;-&quot;</span>))&#123;<br> System.out.println(retval);<br>&#125;  <br><span class="hljs-comment">// 分隔符返回值 :Welcome  to  Runoob</span><br><span class="hljs-comment">// 此方法常用来字符串-&gt;字符串数组(输入模式下的输入数组后的处理)</span><br></code></pre></td></tr></table></figure><br/>#### 3.StringBuilder的delete()与deleteCharAt()<p>两个都是用来删除StringBuilder字符串指定索引处字符的方法</p><p>delete（int a,int b）有两个参数，删除索引从[a,b)的字符；</p><p>deleteCharAt（int a）只有一个参数，使用时删除索引为a的字符；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buff</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;0123456789&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;buff=&quot;</span>+buff);<br><br><span class="hljs-comment">//删除下标从3到5的字符</span><br>buff.delete(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>System.out.println(<span class="hljs-string">&quot;deletionBack=&quot;</span>+ buff);<br><br>buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;0123456789&quot;</span>);<br><span class="hljs-comment">//删除下标为8字符</span><br>buff.deleteCharAt(<span class="hljs-number">8</span>);<br>System.out.println(<span class="hljs-string">&quot;delectCharAtBack=&quot;</span>+buff);<br><span class="hljs-comment">// 输出如下:</span><br><span class="hljs-comment">// buff=0123456789</span><br><span class="hljs-comment">// deletionBack=01256789</span><br><span class="hljs-comment">// delectCharAtBack=012345679</span><br></code></pre></td></tr></table></figure><h3 id="br-4-List与数组互相转换"><br/>4.List与数组互相转换</h3><p>具体参考<a href="https://blog.csdn.net/Gc_680/article/details/122568085">Java：List与数组相互转换</a></p><br/><h4 id="5-字符-字符串">5.字符-&gt;字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String.valueOf(str.charAt(i))<br></code></pre></td></tr></table></figure><h3 id="br-6-StringBuilder的append-方法可以接受很多种类型"><br/>6.<strong>StringBuilder的append()方法可以接受很多种类型</strong></h3><p><img src="../images/p2.jpg" alt=""></p><br/><h3 id="7-StringBuilder的setCharAt-方法">7.StringBuilder的setCharAt()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个参数为索引,第二个参数为该索引处设置的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCharAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">char</span> ch)</span><br>sb.setCharAt(end, temp);<br></code></pre></td></tr></table></figure><br/><h3 id="8-重载的remove-方法">8.重载的remove()方法</h3><p>ArrayList有两个remove()重载法，分别是:remove(int index) remove(Object o)</p><p>若参数输入为1，到底是删除对象1还是删除索引为1的元素呢?</p><p>最后发现：<strong>remove(1)是删除索引为1的元素；remove(new Integer(1))则删除元素1</strong></p><p>因为1默认是基本类型int</p><br/><h3 id="9-数组转List集合方法：-注意包装类型">9.数组转List集合方法：(注意包装类型)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">方法<span class="hljs-number">1</span>:<br>Integer[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 这里不能用int</span><br>Arrays.fill(nums,<span class="hljs-number">1</span>);<br>List&lt;Integer&gt; list = Arrays.asList(nums);<br><br>方法<span class="hljs-number">2</span>:<br>Integer[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">5</span>];<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, nums);<br></code></pre></td></tr></table></figure><br/><h3 id="10-Java中的Math-atan2-double-x-double-y-方法">10.Java中的Math.atan2(double x, double y)方法</h3><p>将指定的直角坐标(x, y)转换为极坐标(r, θ)，并返回弧度θ。</p><p>该方法通过计算 y/x 的反正切值来计算弧度θ，值域为(-π, π]。</p><p><strong>atan2与atan区别：</strong></p><p>参数个数不同：atan(double a)，而atan2(double y, double x)。</p><p>参数含义不同：atan中的参数a一般传y/x，也就是斜率k，而atan2中的两个参数就是实际中的x坐标和y坐标。</p><p>值域不同：atan值域为(-π/2,π/2)，而atan2的值域为[-π,π]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, y = <span class="hljs-number">2</span>;<br>    System.out.println(Math.atan2(y, x)); <span class="hljs-comment">// 0.7853981633974483</span><br>    System.out.println(Math.atan(y / x)); <span class="hljs-comment">// 0.7853981633974483</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, y2 = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, y1 = <span class="hljs-number">1</span>;<br>    System.out.println(Math.atan2(y2 - y1, x2 - x1)); <span class="hljs-comment">// 0.7853981633974483(45°)</span><br>    System.out.println(Math.atan((y2 - y1) / (x2 - x1))); <span class="hljs-comment">// 0.7853981633974483</span><br>    <span class="hljs-comment">// 下面有区别</span><br>    System.out.println(Math.atan2(y1 - y2, x1 - x2)); <span class="hljs-comment">// -2.356194490192345(-135°)</span><br>    System.out.println(Math.atan((y1 - y2) / (x1 - x2))); <span class="hljs-comment">// 0.7853981633974483</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="11-TreeSet返回最小元素与最大元素的API">11.TreeSet返回最小元素与最大元素的API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(排序规则));<br><span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> set.first();<span class="hljs-comment">// 排序规则的首个元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> set.last();<span class="hljs-comment">// 排序规则的最后一个元素</span><br>set.remove(o);<span class="hljs-comment">// 移除对应元素</span><br></code></pre></td></tr></table></figure><br/><h3 id="12-关于TreeSet自定义排序规则后修改规则中元素的问题">12.关于TreeSet自定义排序规则后修改规则中元素的问题</h3><p><strong>与规则相关并有扰乱顺序的风险</strong>时，必须确保这个元素的排序是没有被影响过的，否则在remove()时，会出现定位失败，有可能删除失败，或者删除出错！</p><p>因此，当我们用TreeSet作为一个自动排序容器时，更新元素的位置，必须分三个步骤：</p><p><strong>1、remove老的元素</strong></p><p><strong>2、修改</strong></p><p><strong>3、插入修改后的元素</strong></p><p>PS:set.add(T t)如果存在了，将不会进行任何操作并返回false</p><p><a href="https://leetcode.cn/problems/design-a-food-rating-system/"><strong>6126. 设计食物评分系统</strong></a></p><p><strong>参考：</strong><a href="https://www.cnblogs.com/chzcb/p/3984681.html"><strong>关于TreeSet的排序对于删除操作的影响</strong></a></p><br/><h3 id="13-List数组的正确写法">13.List数组的正确写法</h3><p>创建时候指定类型，然后统一初始化一次，后面直接add即可</p><p>这里也用到List存图的方式，比较适合稀疏图，因为List容量可变</p><p>通常来说邻接矩阵适合稠密图，稀疏图可以采用HashMap（离散化程度大）或者List数组(离散化程度小/节点索引为[1,n]情形)</p><p><a href="https://leetcode.cn/problems/course-schedule/"><strong>207. 课程表</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] pres)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    拓扑排序:</span><br><span class="hljs-comment">    只要课程没有循环依赖(成环)，就可以顺利按照拓扑排序的规则完成所有课程</span><br><span class="hljs-comment">    思路就是优先消除入度为0的课程，因为这个课程可以直接学不用依赖别的课程</span><br><span class="hljs-comment">    消除到最后看看还有没有没哟被消去的课程即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 存储课程之间的依赖关系，比如0依赖1，list[0]中就有1</span><br>    List&lt;Integer&gt;[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        list[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : pres) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">0</span>], pre = p[<span class="hljs-number">1</span>];<br>        list[pre].add(next);<br>    &#125;<br>    <span class="hljs-type">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];    <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : list[i]) &#123;<br>            inDegree[num]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 统计入度为0的节点</span><br>    Queue&lt;Integer&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            que.add(i);<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> que.poll();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : list[poll]) &#123;<br>            <span class="hljs-keyword">if</span> (--inDegree[num] == <span class="hljs-number">0</span>) &#123;<br>                que.add(num);<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="14-关于static关键字在力扣提交的速度优化">14.关于static关键字在力扣提交的速度优化</h3><p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/"><strong>375. 猜数字大小 II</strong></a></p><p>优化前代码如下 <strong>(67ms/40.2MB)</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo;   <span class="hljs-comment">// memo[i][j]记录猜中区间[i,j]之间所需的最少钱数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// memo中存在</span><br>        <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> INF;   <span class="hljs-comment">// 最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++) &#123;<br>            <span class="hljs-comment">// 维护合法分割点的最小钱数</span><br>            <span class="hljs-comment">// 当前分割点的钱数=分割点k猜错的开销+左右区间开销大的一边(保证任意数字都可通过该最大开销猜中)</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> k + Math.max(dfs(i, k - <span class="hljs-number">1</span>), dfs(k + <span class="hljs-number">1</span>, j));<br>            min = Math.min(min, cur);<br>        &#125;<br>        memo[i][j] = min;   <span class="hljs-comment">// 记录猜中当前区间的最小钱值</span><br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>static优化后 <strong>(8ms/38.1MB)</strong> ：</p><p>注意static的优化要在成员里面加上static并且有相应的初始化器</p><p><code>static int[][] memo = new int[201][201]; </code></p><p><code>static int INF = 0x3f3f3f3f;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">201</span>][<span class="hljs-number">201</span>];   <span class="hljs-comment">// memo[i][j]记录猜中区间[i,j]之间所需的最少钱数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// memo中存在</span><br>        <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> INF;   <span class="hljs-comment">// 最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++) &#123;<br>            <span class="hljs-comment">// 维护合法分割点的最小钱数</span><br>            <span class="hljs-comment">// 当前分割点的钱数=分割点k猜错的开销+左右区间开销大的一边(保证任意数字都可通过该最大开销猜中)</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> k + Math.max(dfs(i, k - <span class="hljs-number">1</span>), dfs(k + <span class="hljs-number">1</span>, j));<br>            min = Math.min(min, cur);<br>        &#125;<br>        memo[i][j] = min;   <span class="hljs-comment">// 记录猜中当前区间的最小钱值</span><br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从67ms直接优化到8ms优化效果超级理想</p><p><strong>注意：有部分题型不能在成员中初始化static变量否则会出错！如下：</strong></p><p><a href="https://leetcode.cn/problems/stone-game/"><strong>877. 石子游戏</strong></a></p><p><a href="https://leetcode.cn/problems/strange-printer/"><strong>664. 奇怪的打印机</strong></a></p><br/><h3 id="15-维护两个集合（数组）中前两个最大值">15.维护两个集合（数组）中前两个最大值</h3><p>有时候我们不仅要求最大值，有可能还要实时维护次大值，次大值可能会用到</p><p>如何高效地维护最大值与次大值呢？最高效的方法就是利用两个变量max1（最大值）与max2（次大值）进行滚动维护</p><p>当遇到下一个数字nums[i]&gt;max1大，此时max2=max1；max1=nums[i]</p><p>也就是说原来的max1取代了原来的max2，而nums[i]取代原来max1位置（卷起来了）</p><p>而max1&gt;=nums[i]&gt;max2时，我们令nums[i]取代原来max2位置，原来的max2就被取代了</p><p>当nums[i]==max2 可以维持原状，当nums[i]</p><p><strong>PS：</strong> 当然，如果我们不熟悉的话可以用优先队列去维护，甚至维护前k大元素都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        考虑两种间隔的前两个最大值+分类讨论</span><br><span class="hljs-comment">        要想最少操作次数，就要充分利用原理有出现的数字</span><br><span class="hljs-comment">        记偶数索引的最多出现的数字为a1，次多出现的数字为a2</span><br><span class="hljs-comment">        记奇数索引的最多出现的数字为b1，次多出现的数字为b2</span><br><span class="hljs-comment">        1.当a1!=b1 这是最理想的结果，直接将其他数字改成a1与b1，总的操作次数为n-(m1[a1]+m2[b1])</span><br><span class="hljs-comment">        2.当a1==b1 此时就有点麻烦了，不能同时将其他数字变为a1与b1因为会产生冲突</span><br><span class="hljs-comment">            此时我们可以有两种选择:选a1与b2 或 a2与b1 (a2与b2数目不多于前两者可以忽略)</span><br><span class="hljs-comment">            取数目总和大的，最后结果为:n-max(m1[a1]+m2[b2],m1[a2]+m2[b1])</span><br><span class="hljs-comment">        重点就是如何维护两个最大值了</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] m1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100010</span>], m2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100010</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, a2 = <span class="hljs-number">0</span>, b1 = <span class="hljs-number">0</span>, b2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 偶数索引</span><br>                m1[nums[i]]++;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> m1[nums[i]];  <span class="hljs-comment">// cur为当前数字nums[i]出现的次数</span><br>                <span class="hljs-keyword">if</span> (a1 == <span class="hljs-number">0</span> || cur &gt; m1[a1]) &#123;  <span class="hljs-comment">// 最大出现次数的数字还没出现||当前数字出现次数已经大于a1出现次数</span><br>                    <span class="hljs-comment">// nums[i]取代a1位置，之前的a1退居a2位置</span><br>                    a2 = a1;<br>                    a1 = nums[i];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] != a1 &amp;&amp; (a2 == <span class="hljs-number">0</span> || cur &gt; m1[a2])) &#123;<br>                    <span class="hljs-comment">// nums[i]!=a1说明这个nums[i]不是最大值的，此时若次大值处还没赋值或者nums[i]出现次数比原先的a2多</span><br>                    <span class="hljs-comment">// 那么nums[i]可以取代原来a2的位置</span><br>                    a2 = nums[i];<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 奇数索引</span><br>                m2[nums[i]]++;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> m2[nums[i]];<br>                <span class="hljs-keyword">if</span> (b1 == <span class="hljs-number">0</span> || cur &gt; m2[b1]) &#123;<br>                    b2 = b1;<br>                    b1 = nums[i];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] != b1 &amp;&amp; (b2 == <span class="hljs-number">0</span> || cur &gt; m2[b2])) &#123;<br>                    b2 = nums[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a1 != b1) <span class="hljs-keyword">return</span> n - (m1[a1] + m2[b1]);<br>        <span class="hljs-keyword">return</span> n - Math.max(m1[a1] + m2[b2], m1[a2] + m2[b1]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="16-最大公约数gcd与最小公倍数">16.最大公约数gcd与最小公倍数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BiggestFactor</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>        System.out.println(a + <span class="hljs-string">&quot;与&quot;</span> + b + <span class="hljs-string">&quot;最大公约数为:&quot;</span> + maxCommonFactor(a, b));<br>        System.out.println(a + <span class="hljs-string">&quot;与&quot;</span> + b + <span class="hljs-string">&quot;最小公倍数为:&quot;</span> + minCommonMultiple(a, b));<br>    &#125;<br><br>    <span class="hljs-comment">// 最小公倍数:结合最大公约数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCommonMultiple</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a * b / maxCommonFactor(a, b);<br>    &#125;<br><br>    <span class="hljs-comment">// 最大公约数:辗转相除法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCommonFactor</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> a % b;<br>            a = b;<br>            b = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-comment">// return b &gt; 0 ? gcd(b, a % b) : a; (一步到位写法)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拓展：求一个数组的最大公约数-&gt; 滚动因子 O(N)</strong></p><p><a href="https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/"><strong>6122. 使数组可以被整除的最少删除次数</strong></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] numsDivide)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    求最大公因数问题：</span><br><span class="hljs-comment">    原问题等价于求numsDivide的最大公因数maxFac，只要在nums中找到一个可以整除maxFac的数字，那么该数字必定可以被numsDivide所有数整除</span><br><span class="hljs-comment">    将nums排序后找出最小的可以满足上述条件的数字，那么该数字前面的数字就是要删除的数字数目</span><br><span class="hljs-comment">    关键是怎样在接近O(N)时间复杂度内求解数组的最大公因数?</span><br><span class="hljs-comment">    答案是利用前面部分的maxFac与numsDivide[i]求最大公因数，求出来的就表示满足numsDivide[0,i-1]+numsDivide[i]=numsDivide[0,i]的最大公因数</span><br><span class="hljs-comment">    当遍历整个数组就是整个数组的最大公因数</span><br><span class="hljs-comment">     */</span><br>    Arrays.sort(nums);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> numsDivide.length, n = nums.length;<br>    <span class="hljs-comment">// 求数组的最大公因数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxFac</span> <span class="hljs-operator">=</span> numsDivide[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        maxFac = gcd(maxFac, numsDivide[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (maxFac % nums[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 求a与b的最大公约数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> b &gt; <span class="hljs-number">0</span> ? gcd(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>同理可以求得整个数组的最小公倍数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCommonMultiple</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.lebnght; i++) &#123;<br>        res = maxCommonFactor(res, nums[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 最小公倍数:结合最大公约数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCommonMultiple</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a * b / maxCommonFactor(a, b);<br>    &#125;<br><br>    <span class="hljs-comment">// 最大公约数:辗转相除法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCommonFactor</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> a % b;<br>            a = b;<br>            b = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-comment">// return b &gt; 0 ? gcd(b, a % b) : a; (一步到位写法)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="17-螺旋矩阵模拟转向trick">17.螺旋矩阵模拟转向trick</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-iv/">6111. 螺旋矩阵 IV</a></p><p>周赛中发现了灵神的这个模拟转向的小trick 可以应用至任意的螺旋矩阵题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] spiralMatrix(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, ListNode head) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        一个模拟的万能转向trick(参考灵神)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            Arrays.fill(res[i], -<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 上右下左四个进给方向</span><br>        <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-comment">// idx为进给方向,x与y是遍历指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>, y = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 为了进给第一步向右走了之后才赋值,初始化(x,y)=(0.-1)</span><br>        <span class="hljs-comment">// 链表还没走完就继续循环</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dirs[idx][<span class="hljs-number">0</span>], newY = y + dirs[idx][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 越界或者碰到已经覆盖过的-&gt;转向</span><br>            <span class="hljs-keyword">if</span> (newX &lt; <span class="hljs-number">0</span> || newX &gt;= m || newY &lt; <span class="hljs-number">0</span> || newY &gt;= n || res[newX][newY] != -<span class="hljs-number">1</span>) idx = (idx + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            x += dirs[idx][<span class="hljs-number">0</span>];<br>            y += dirs[idx][<span class="hljs-number">1</span>];<br>            res[x][y] = cur.val;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> Java </tag>
            
            <tag> API </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown格式渲染测试</title>
      <link href="/Markdown%E6%A0%BC%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95.html"/>
      <url>/Markdown%E6%A0%BC%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<p>代码块(```夹着加具体语言)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文字格式测试…</p><h1>H1</h1><h2 id="H2">H2</h2><h3 id="H3">H3</h3><h4 id="H4">H4</h4><h5 id="H5">H5</h5><h6 id="H6">H6</h6><p><u>下划线演示</u>(&lt;u&gt;夹着)</p><p>文字<strong>加粗</strong>演示(**夹着)</p><p>文字<em>斜体</em>演示(*夹着)</p><p>文本<code>高亮</code>演示(`夹着)</p><p>文本<s>删除</s>线演示(~~夹着)</p><p><font size = 5>5号字</font>（&lt;font&gt;夹着并指定size属性）<br><font face="黑体">黑体</font>（&lt;font&gt;夹着并指定face属性）<br><font color=blue>蓝色</font>（&lt;font&gt;夹着并指定color属性）</p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><p>详情参考：<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p><p>一级引用演示(&gt;回车)</p><blockquote><p>Java</p><p>二级引用演示</p><p>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><p>分割线演示(三个连续的*或-)</p><hr><p>无序列表(*,+,-跟空格都可以)</p><ul><li>Java</li><li>Python</li><li>…</li></ul><p>有序列表（数字后面跟.+空格）</p><ol><li></li><li></li><li></li><li></li></ol><p>图片测试(![图片描述]+(图片链接))</p><img src="/images/p1.png" alt="示例图片" style="zoom:50%;" /><p>表格渲染演示</p><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><p>公式渲染效果演示<br>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><p>结尾~~~</p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
